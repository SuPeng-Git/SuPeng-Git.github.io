<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Main</title>
  
  <subtitle>悟已往之不谏，知来者之可追!</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-19T15:13:28.094Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>SuPeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序设计入门</title>
    <link href="http://example.com/2022/01/19/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/19/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-19T14:57:51.743Z</published>
    <updated>2022-01-19T15:13:28.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.8f\n&quot;</span>, <span class="number">1</span>+<span class="number">2</span>*<span class="built_in">sqrt</span>(<span class="number">3</span>)/(<span class="number">5</span><span class="number">-0.1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>整数值用%d输出，实数值用%f输出</li><li>整数/整数 = 整数， 浮点数/浮点数 =  浮点数</li><li>C语言类型的自动转换</li><li>C语言类型的强制转换</li></ul></blockquote><h1 id="变量及其输入"><a href="#变量及其输入" class="headerlink" title="变量及其输入"></a>变量及其输入</h1><p><strong>例题1-1　圆柱体的面积</strong></p><p>输入底面半径r和高h，输出圆柱体的面积，保留3位小数，格式见样例。<br>样例输入：<br>3.5<br>9<br>样例输出：<br>Area = 247.889</p><p>【分析】<br>圆柱体表面积 = 底面积*2+侧面积<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> r, h, s1, s2, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;r, &amp;h);</span><br><span class="line">    s1 = pi*r*r;</span><br><span class="line">    s2 = <span class="number">2</span>*pi*r*h;</span><br><span class="line">    s = s1*<span class="number">2.0</span> + s2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Area = %.3f\n&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>scanf中的占位符和变量的数据类型一一对应，且每个变量前需要加“&amp;”符号（取址符）。</li><li>在算法比赛中，输入前不要打印提示信息。输出完毕后应立即终止程序，不要等待用户按键，因为输入输出过程都是自动的，没有人工干预。</li><li>在算法比赛中不要使用头文件conio.h,包括getch(),clrscr()等函数。</li><li>在算法竞赛中，每行输出均应以回车符结束，包括最后一行。除特别说明，每行的行首不应有空格，但行末通常可以有多余空格。另外，输出的每两个数或者字符串应以单个空格隔开。</li><li>尽量用const关键字声明常数。</li><li>赋值是个动作，先计算右边的值，再赋值给左边的变量，覆盖它原来的值。=、+=、-=、*=、%=等赋值运算符都是右结合。</li><li>printf的格式字符串中可以包含其他可打印符号，打印时原样输出。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">《算法竞赛入门经典》读书笔记，待完善</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="入门" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
    <category term="《算法竞赛入门经典》" scheme="http://example.com/tags/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python基础知识</title>
    <link href="http://example.com/2022/01/17/Python/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/01/17/Python/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-01-17T13:06:59.003Z</published>
    <updated>2022-01-17T13:23:57.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python对象模型"><a href="#Python对象模型" class="headerlink" title="Python对象模型"></a>Python对象模型</h1><p>| 对象类型 | 类型名称 | 简要说明 |</p><h1 id="Python变量"><a href="#Python变量" class="headerlink" title="Python变量"></a>Python变量</h1><p><strong>Python变量的创建</strong></p><p>在Python中，不需要事先声明变量名及其类型，直接赋值即可创建各种类型的变量。</p><p>Python是一种动态型语言——变量的类型可以随时改变。</p><p>大多数情况下，如果变量出现在赋值运算符的活复合赋值运算符的左边表示创建变量或修改变量的值，否则表示引用该变量的值，这一点同样适用于使用下标来访问列表、字典等可变序列以及其他自定义对象中元素的情况。字符串和元组属于不可变序列，这意味着不可通过下标的方式来修改其中的元素值。</p><p>修改变量的值实际修改的是变量的引用，其内存地址会发生变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">22704288</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">22704304</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(y)</span><br><span class="line"><span class="number">22704304</span></span><br></pre></td></tr></table></figure><p><strong>内置函数id()</strong>：返回变量所指值的内存地址。</p><p>Python采用基于值的内存管理方式，如果为不同变量赋值为相同值，这个值在内存中只保存一份，多个变量指向同一个值的内存空间首地址，以减少内存空间的占用，提高内存使用效率。Python启动时，会对[-5,256]的整数进行缓存。对于区间[-5,256]之外的整数，同一个程序中或交互模式下同一个语句中的同值不同名变量会共用同一个内存空间，不同程序或交互模式下不同语句不遵守这个约定。</p>]]></content>
    
    
    <summary type="html">Python基础语法，《Python程序设计》（第三版）读书笔记 ，待完善</summary>
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Python" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>C++基础知识</title>
    <link href="http://example.com/2022/01/17/C++/C++%E7%B2%BE%E7%AE%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/01/17/C++/C++%E7%B2%BE%E7%AE%80%E8%AF%AD%E6%B3%95/</id>
    <published>2022-01-16T16:05:55.387Z</published>
    <updated>2022-01-20T11:38:17.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用变量：-amp"><a href="#引用变量：-amp" class="headerlink" title="引用变量：&amp;"></a>引用变量：&amp;</h1><p><strong>创建引用声明：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType &amp; name = variate;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：必须在声明引用变量时进行初始化。</strong></p></blockquote><p><strong>将引用用作函数参数——按引用传递</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值函数名(ElementType &amp; name,ElementType &amp; name)&#123;&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>临时变量 、引用参数和const</strong></p><blockquote><p>如果引用参数是const，则编译器将在下面两种情况下生成<strong>临时变量</strong>：</p><ol><li>实参的类型正确，但不是左值</li><li>实参的类型不正确，但可以转换为正确的类型</li></ol><p>注意：如果函数调用的参数不是左值或与之对应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，<br>将函数调用的参数的值传递给匿名变量，并让参数来引用该变量。</p><p><strong>尽可能使用const</strong></p><ol><li>使用const可以避免无意中修改数据的变长错误；</li><li>使用const使函数能够处理const和非const实参，否则将只能接受非const数据；</li><li>使用const引用使函数能够正确生成并使用临时变量。</li></ol></blockquote><p><strong>返回引用</strong></p><blockquote><p>返回引用的函数实际上是被引用的变量的别名。<br>返回引用应避免返回函数终止时不再存在的内存单元引用。<br>为避免这种问题，可以考虑返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用也指向这些数据。<br>另一种方法是用new类分配新的存储空间。但在不再需要new分配内存时，用使用delete来释放它们。<br>返回const引用—即不可修改的左值</p></blockquote><p><strong>何时使用引用参数</strong></p><blockquote><p>使用引用参数的主要原因：<br>程序员能够修改调用的函数中的数据对象<br>通过传递引用而不是整个数据对象，可以提高程序的运行速度。</p></blockquote><p>对于使用传递的值而不做修改的函数：</p><ul><li>如果数据对象很小，若内置数据类型或小型结构，则按值传递</li><li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。</li><li>如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省赋值结构所需的时间和空间。</li><li>如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。</li></ul><p>对于修改调用函数中数据的函数:</p><ul><li>如果数据对象是内置数据类型，则使用指针。</li><li>如果数据对象是数组，则只能使用指针。</li><li>如果数据对象是结构，则使用引用或指针。</li><li>如果数据对象是类对象，则使用引用。</li></ul><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p><strong>默认参数</strong>：指的是当函数调用中省略了实参时自动使用的一个值。</p><p><strong>默认参数的设置</strong></p><p>将默认值赋给原型中的参数。只有原型包含默认值的信息,函数定义无需修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[返回值类型] [函数名](ElementType _val = [默认值]);</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>在函数调用中，实参按从左往右的顺序依次被赋给形参，而不能跳过任何参数。</li><li>如果某个位置有了默认参数，那么从这个位置往后都要有默认值。即只能在参数列表中从右到左提供默认参数。因此，如果为某个参数提供了默认值，则必须为该参数右边所有的参数提供默认值。</li></ul></blockquote><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>函数多态是C++在C语言基础上新增的功能。默认参数允许使用不同数目的参数调用同一个函数，而函数多态（函数重载）允许使用多个同名的函数。</p><p>术语“多态”指的是有多种形式，因此函数多态允许函数可以有多种形式。术语“函数重载”指的是可以有多个同名的函数，第名称进行了重载。</p><p>函数重载的关键是函数的参数列表——也称为函数的特征标。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。</p><p>注意：类型引用和类型本身视为同一特征标。</p><p><strong>何时使用函数重载</strong>：仅当函数基本上执行相同的任务，但使用不同形式的数据时使用函数重载。</p><blockquote><p>拓展：名称修饰</p><p>C++编译器执行一些神奇的操作——名称修饰或名名称矫正，它根据函数原型中指定的形参类型对每个函数进行加密。</p></blockquote><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p><strong>函数模板</strong>：函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。</p><p><strong>建立函数模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;</span><br><span class="line">[返回值类型] [函数名](AnyType a, AnyType b)&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行指出，要建立一个函数模板，并将类型命名为AnyType。类型名可以自定义，但要遵守C++命名规范。关键字template和typename是必需的。在标准C++98添加关键字typename之前，C++使用关键字class来创建模板。</p><p><strong>提示</strong>：如果需要多个将同一种算法用于不同类型的函数，则使用模板。如果不考虑向后兼容的问题，并愿意键入较长的单词，则声明类型参数时，应使用typename而不使用class。</p><p><strong>函数模板重载</strong></p><p>和常规函数重载相同，被重载的模板的函数特征标必须不同。</p><p><strong>模板的局限性</strong></p><p>编写的模板函数很可能无法处理某些类型。</p><p><strong>显示具体化</strong></p><p>当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。</p><ul><li>第三代具体化（ISO/ANSI C++标准）</li></ul><p>对于给定的函数名，可以有非模板函数、模板函数和显示具体化模板函数以及它们的重载版本。<br>显示具体化的原型和定义应以template&lt;&gt;打头，并通过名称来指出类型。<br>具体化优先于常规模板，而非模板函数优先于具体化和常规化模板。</p><p><strong>实例化和具体化</strong></p><ul><li>模板实例：编译器使用模板为特定类型生成函数定义时，得到的是模板实例。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">0.2</span>;</span><br><span class="line">cout &lt;&lt; Add&lt;<span class="keyword">double</span>&gt;(x, x);  <span class="comment">//显示示例</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>(m , m); <span class="comment">//隐式实例化</span></span><br></pre></td></tr></table></figure><ul><li>具体化（specialization）：隐式实例化、显示实例化和显示实例化统称具体化。它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。</li></ul><blockquote><p>引用显示实例化后，必须使用新的语法——在声明中使用前缀template和template&lt;&gt;，以区分显示实例化和具体实例化。</p><p>警告：试图在同一文件（或转换单元）中使用同一种类型的显示实例化和显式具体化将出错。</p></blockquote><p><strong>编译器选择使用哪个函数版本</strong></p><ul><li>重载解析：C++通过已确立的策略来决定为函数调用使用哪一个函数定义的过程称为重载解析。<blockquote><ol><li>第一步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。</li><li>第二部：使用候选函数列表创建可行函数。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包含实参类型与相应的形参类型完全的情况。</li><li>第三步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。</li></ol></blockquote></li></ul><ol><li>完全匹配和最佳匹配</li></ol><div class="table-container"><table><thead><tr><th>从实参</th><th>到形参</th></tr></thead><tbody><tr><td>Type</td><td>Type &amp;</td></tr><tr><td>Type &amp;</td><td>Type</td></tr><tr><td>Type []</td><td>*Type</td></tr><tr><td>Type (argument)</td><td>Type * (argument)</td></tr><tr><td>Type</td><td>const Type</td></tr><tr><td>Type</td><td>volatile Type</td></tr><tr><td>Type*</td><td>const Type</td></tr><tr><td>Type*</td><td>volatile Type*</td></tr></tbody></table></div><p>如果有多个匹配的原型，则编译器将无法完成重载解析过程；如果没有最佳的可行函数，则编译器将生成一条错误消息，该消息可能会使用诸如“ambiguous（二义性）”这样的词语。然而，有时候，即使两个函数都完全匹配，仍可完成重载解析。首先，指向非const数据的指针和引用优先与非const指针和引用参数匹配。const和非const之间的区别只适用于指针和引用指向的数据。</p><p>一个完全匹配优于另一个的另一种情况是，其中一个时非模板函数，而另一个不是。在这种情况下，非模板函数优先于模板函数（包括显式具体化）。具体化优先于常规模板，而非模板函数优先于具体化和常规化模板。</p><p>如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先。例如，这意味着显式具体化将优于使用模板隐式生成的具体化。</p><p>术语“最具体（most specialized）”并不一定意味着显式具体化，而是指编译器推断使用哪种类型时执行的转换最少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="function"><span class="keyword">void</span> <span class="title">recycle</span> <span class="params">(Type t)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="function"><span class="keyword">void</span> <span class="title">recycle</span> <span class="params">(Type * t)</span></span>; <span class="comment">// #2</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blot</span> &#123;</span><span class="keyword">int</span> a; <span class="keyword">char</span> b[<span class="number">10</span>];&#125;;</span><br><span class="line">blot ink = &#123;<span class="number">25</span>, <span class="string">&quot;spots&quot;</span>&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">recycle</span>(&amp;ink); <span class="comment">// address of a structure</span></span><br></pre></td></tr></table></figure><blockquote><p>recycle(&amp;ink)调用与#1模板匹配，匹配时将Type解释为blot <em>。recycle(&amp;ink)函数调用也与#2模板匹配，这次Type被解释为blot。因此将两个隐式实例——recycle&lt;blot </em>&gt;(blot <em>)和recycle <blot>(blot </em>)发送到可行函数池中。<br>在这两个模板函数中，recycle<blot *>(blot *)被认为是更具体的，因为在生成过程中，它需要进行的转换更少。也就是说，#2模板已经显式指出，函数参数是指向Type的指针，因此可以直接用blot标识Type；而#1模板将Type作为函数参数，因此Type必须被解释为指向blot的指针。也就是说，在#2模板中，Type已经被具体化为指针，因此说它“更具体”。</p></blockquote><p>用于找出最具体的模板的规则被称为函数模板的部分排序规则（partial ordering rules）。和显式实例一样，这也是C++98新增的特性。</p><ol><li>创建自定义选择</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[函数名]&lt;&gt;([实参]);</span><br><span class="line"><span class="comment">// &lt;&gt;指出，编译器应选择模板函数，而不是非模板函数；</span></span><br><span class="line">[函数名]&lt;类型&gt;([实参]);</span><br><span class="line"><span class="comment">// &lt;类型&gt;要求进行显示实例化</span></span><br></pre></td></tr></table></figure><p><strong>关键字decltype（C++11）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression) var;<span class="comment">// make var the same type as x;</span></span><br></pre></td></tr></table></figure><p>给decltype提供的参数可以是表达式、标识符。</p><ul><li>如果expression是一个没有用括号括起的标识符，则var的类型与该标识符的类型相同，包括const等限定符。</li><li>如果expression是一个函数调用，则var的类型与函数的返回类型相同。</li><li>如果expression是一个左值，则var为指向其类型的引用。expression是用括号括起的标识符。</li><li>如果前面的条件都不满足，则var的类型与expression的类型相同</li></ul><blockquote><p>注意：<br>给decltype提供的参数是表达式时，并不会调用函数。编译器通过查看函数的原型来获悉返回类型，而无需调用函数。<br>括号并不会改变表达式的值和左值性。</p></blockquote><p><strong>另一种函数声明语法——C++11后置返回类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">gt</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将返回类型移到了参数声明后面。-&gt;double被称为后置返回类型（trailing return type）。其中auto是一个占位符，表示后置返回类型提供的类型，这是C++11给auto新增的一种角色。这种语法也可用于函数定义.</p><h1 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h1><h2 id="传统的C-名称空间"><a href="#传统的C-名称空间" class="headerlink" title="传统的C++名称空间"></a>传统的C++名称空间</h2><p><strong>声明区域（declaration）</strong>：声明区域是可以在其中进行声明的区域。</p><p><strong>潜在作用域（potential scope）</strong>：变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。</p><p><strong>作用域（scope）</strong>：变量对程序而言可见的范围被称为作用域。</p><blockquote><p>变量并非在其潜在作用域内的任何位置都是可见的。例如，它可能被另一个在嵌套声明区域中声明的同名变量隐藏。例如，在函数中声明的局部变量（对于这种变量，声明区域为整个函数）将隐藏在同一个文件中声明的全局变量（对于这种变量，声明区域为整个文件）。</p></blockquote><p>C++关于全局变量和局部变量的规则定义了一种名称空间层次。每个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的名称。在一个函数中声明的局部变量不会与在另一个函数中声明的局部变量发生冲突。</p><h2 id="新的空间特性"><a href="#新的空间特性" class="headerlink" title="新的空间特性"></a>新的空间特性</h2><p>C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。</p><p>名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。</p><p><strong>全局空间</strong>：除了用户定义的名称空间外，还存在另一个名称空间——全局名称空间（global namespace）。它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中。</p><p>任何名称空间中的名称都不会与其他名称空间中的名称发生冲突。</p><p>未被装饰的名称（如pail）称为未限定的名称（unqualified name）；包含名称空间的名称（如Jack::pail）称为限定的名称（qualified name）。</p><h3 id="using声明和using编译"><a href="#using声明和using编译" class="headerlink" title="using声明和using编译"></a>using声明和using编译</h3><p>using声明使特定的标识符可用，using编译指令使整个名称空间可用。</p><p><strong>using声明</strong>：using声明由被限定的名称和它前面的关键字using组成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Jill::fetch; <span class="comment">// a using declaration</span></span><br></pre></td></tr></table></figure></p><p>using声明将特定的名称添加到它(using声明)所属的声明区域中。</p><p><strong>using编译</strong>：using声明使一个名称可用，而using编译指令使所有的名称都可用。using编译指令由名称空间名和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Jack; <span class="comment">// make all the names in Jack available</span></span><br></pre></td></tr></table></figure></p><p>使用using编译和using声明增加了名称冲突的可能，存在二义性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jack::pal = <span class="number">3</span>;</span><br><span class="line">jill::pal =<span class="number">10</span>;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">using</span> jack::pal;</span><br><span class="line"><span class="keyword">using</span> jill::pal;</span><br><span class="line">pal = <span class="number">4</span>;       <span class="comment">// which one? now have a conflict</span></span><br></pre></td></tr></table></figure></p><h3 id="using编译指令和using声明之比较"><a href="#using编译指令和using声明之比较" class="headerlink" title="using编译指令和using声明之比较"></a>using编译指令和using声明之比较</h3><p>如果某个名称已经在函数中声明了，则不能用using声明导入相同的名称。如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。</p><blockquote><p>注意：<br>假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，则这两个名称会发生冲突，从而出错。如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。</p></blockquote><h3 id="名称空间的其他特性"><a href="#名称空间的其他特性" class="headerlink" title="名称空间的其他特性"></a>名称空间的其他特性</h3><p><strong>可嵌套</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> elements</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> fire</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flame;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> water;</span><br><span class="line">&#125;   <span class="comment">//无分号;</span></span><br></pre></td></tr></table></figure></p><p><strong>*using编译指令的传递性</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myth</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Jill::fetch;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> elements;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::cin;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> myth;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> myth;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> elements;</span><br><span class="line"><span class="comment">// 与using namespace myth;等价</span></span><br></pre></td></tr></table></figure></p><p><strong>名称空间的别名</strong><br>可以给名称空间创建别名。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MH = myth;</span><br></pre></td></tr></table></figure></p><p><strong>未命名的名称空间</strong><br>可以通过省略名称空间的名称来创建未命名的名称空间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="comment">// unnamed namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ice;</span><br><span class="line">    <span class="keyword">int</span> bandycoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于这种名称空间没有名称，因此不能显式地使用using编译指令或using声明来使它在其他位置都可用。具体地说，不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称。这提供了链接性为内部的静态变量的替代品。</p><p><strong>关于名称空间的使用规范</strong></p><blockquote><ul><li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</li><li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</li><li>如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++当前提倡将标准函数库放在名称空间std中，这种做法扩展到了来自C语言中的函数。例如，头文件math.h是与C语言兼容的，没有使用名称空间，但C++头文件cmath应将各种数学库函数放在名称空间std中。实际上，并非所有的编译器都完成了这种过渡。</li><li>仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。</li><li>不要在头文件中使用using编译指令。这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include之后。</li><li>导入名称时，首选使用作用域解析运算符或using声明的方法。</li><li>对于using声明，首选将其作用域设置为局部而不是全局。</li></ul></blockquote><h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><h2 id="抽象和类"><a href="#抽象和类" class="headerlink" title="抽象和类"></a>抽象和类</h2><p><strong>类</strong>：类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。</p><p><strong>接口</strong>：接口是一个共享框架，供两个系统（如在计算机和打印机之间或者用户或计算机程序之间）交互时使用。</p><p>通常，C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码文件中。这里采用这种典型做法。</p><p><strong>访问控制</strong>：关键字private、public和protect描述了对类成员的访问控制。使用类对象的程序都可以直接访问共有部分，但只能通过共有成员函数或友元函数来访问私有对象。</p><p>类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽象组件。将实现细节放在一起并将它们与抽象分开被称为封装。数据隐藏（将数据放在类的私有部分中）是一种封装，将实现的细节隐藏在私有部分中，也是一种封装。封装的另一个例子是，将类函数定义和类声明放在不同的文件中。</p><p><strong>实现类成员函数</strong></p><p>创建类描述的第二部分：为那些由类声明中的原型表示的成员函数提供代码。成员函数定义与常规函数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：</p><ul><li>定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类；</li><li>类方法可以访问类的private组件。</li></ul><p><strong>内联方法</strong></p><p>其定义位于类声明中的函数都将自动成为内联函数；如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。为此，只需在类实现部分中定义函数时使用inline限定符即可。</p><p>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用的、最简便的方法是：将内联定义放在定义类的头文件中（有些开发系统包含智能链接程序，允许将内联定义放在一个独立的实现文件）。</p><p>根据改写规则（rewrite rule），在类声明中定义方法等同于用原型替换方法定义，然后在类声明的后面将定义改写为内联函数。</p><p><strong>类的声明</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    data member declarations</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    member function prototypes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类声明类似结构声明，可以包括数据成员和函数成员。声明有私有部分，在其中声明的成员只能通过成员函数进行访问；声明还具有公有部分，在其中声明的成员可被使用类对象的程序直接访问。通常，数据成员被放在私有部分中，成员函数被放在公有部分中.</p><p>公有部分的内容构成了设计的抽象部分——公有接口。将数据封装到私有部分中可以保护数据的完整性，这被称为数据隐藏。因此，C++通过类使得实现抽象、数据隐藏和封装等OOP特性很容易。</p><p><strong>实现类成员函数</strong></p><p>可以在类声明中提供完整的函数定义，而不是函数原型，但是通常的做法是单独提供函数定义（除非函数很小）。在这种情况下，需要使用作用域解析运算符来指出成员函数属于哪个类。例如，假设Bozo有一个名为Retort()的成员函数，该函数返回char指针，则其函数头如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Bozo::Retort</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><h2 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h2><p><strong>声明和定义构造函数</strong></p><p><strong>默认构造函数</strong>：默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。如果没有提供任何构造函数，则C++将自动提供默认构造函数。它是默认构造函数的隐式版本，不做任何工作。</p><blockquote><p>同理可得，非默认构造函数是提供了显示初始化值来创建对象的构造函数</p></blockquote><p>当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造函数。如果提供了非默认构造函数（如Stock(const char * co, int n, double pr)），但没有提供默认构造函数，则下面的声明将出错：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock stock1; <span class="comment">// not possible with current constructor</span></span><br></pre></td></tr></table></figure><br>如果要创建对象，而不显式地初始化，则必须定义一个不接受任何参数的默认构造函数。定义默认构造函数的方式有两种。一种是给已有构造函数的所有参数提供默认值。另一种方式是通过函数重载来定义另一个构造函数—— 一个没有参数的构造函数。</p><p>由于只能有一个默认构造函数，因此不要同时采用这两种方式。实际上，通常应初始化所有的对象，以确保所有成员一开始就有已知的合理值。因此，用户定义的默认构造函数通常给所有成员提供隐式初始值。</p><blockquote><p>提示：　<br>在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数。<br>隐式地调用默认构造函数时，不要使用圆括号。</p></blockquote>]]></content>
    
    
    <summary type="html">C++基础语法，《C++ Prime Plus》（第6版）读书笔记，待完善</summary>
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="高级语言" scheme="http://example.com/tags/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>行列式</title>
    <link href="http://example.com/2022/01/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <id>http://example.com/2022/01/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E8%A1%8C%E5%88%97%E5%BC%8F/</id>
    <published>2022-01-16T15:10:31.582Z</published>
    <updated>2022-01-17T13:20:06.879Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>行列式的几何意义</li><li>全排列</li><li>n阶行列式的定义</li><li>行列式的性质</li><li>行列式的性质</li><li>行列式按行按列展开</li></ul></blockquote><span id="more"></span><h1 id="行列式的几何意义"><a href="#行列式的几何意义" class="headerlink" title="行列式的几何意义"></a>行列式的几何意义</h1><p><strong>行列式</strong>可以看做是<strong>有向面积或体积</strong>的概念在一般的<strong>欧几里得空间</strong>中的推广。或者说，在 n 维欧几里得空间中，行列式描述的是一个<strong>线性变换</strong>对“体积”所造成的影响。</p><p><strong>线性变换</strong></p><blockquote><p>线性映射是从一个向量空间V到另一个向量空间W的映射且保持向量的可加性和成比例性，而线性变换是线性空间V到其自身的线性映射。</p><script type="math/tex; mode=display">可加性：L(\vec{v}+\vec{w})=L(\vec{v})+L(\vec{w})\\成比例性：L(c\vec{v})=cL(\vec{v})\\线性变换保持向量加法运算和数乘运算</script><p>微分算子是线性的，即求导具有可加性和成比例性</p></blockquote><p><strong>向量空间</strong></p><blockquote><p>向量空间满足向量加法和数乘规则</p><script type="math/tex; mode=display">\begin{array}&1.\vec{u}+(\vec{v}+\vec{w})=(\vec{u}+\vec{v})+\vec{w}\\2.\vec{v}+\vec{w}=\vec{w}+\vec{v}\\3.向量加法的单位元存在\\ 4.每个向量的加法逆元均存在\\5.a(b\vec{v})=(ab)\vec{v} \\6.向量乘法的单位元存在\\7.a(\vec{v}+\vec{w})=a\vec{v}+a\vec{w} \\8.(a+b)\vec{v}=a\vec{v}+b\vec{v} \\\end{array}</script><p>向量空间亦称线性空间；欧几里得空间是指一类特殊的向量空间，对通常3维空间的向量讨论长度、夹角等几何性质。                                                                                                                                     </p></blockquote><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p><strong>定义：</strong>把n个不同的元素排成一列，叫做n个元素的全排列。简称排列</p><p><strong>逆序数的定义：</strong>对于n个不同不同的元素，先规定各元素之间有一个标准次序，于是在这n个元素的任一排列中，当某一对元素的先后次序与标准次序不同时，就构成了一个逆序。一个排列中所有逆序的总数叫做这个排列的<strong>逆序数</strong>。</p><p>逆序数为奇数的排列叫做奇排列，逆序数为偶数的排列叫做偶排列。</p><blockquote><p>计算逆序数的方法：</p></blockquote><h1 id="n阶行列式的定义"><a href="#n阶行列式的定义" class="headerlink" title="n阶行列式的定义"></a>n阶行列式的定义</h1><p><strong>定义：</strong>设有n^2^个数，排成n行n列的数表</p><script type="math/tex; mode=display">\begin{bmatrix}a_{11} & a_{12} & ... & a_{1n} \\a_{21} & a_{22} & ... & a_{2n} \\...    &   ...  & ... & ...       \\a_{n1} & a_{n2} & ... & a_{nn} \\\end{bmatrix}</script><p>做出表中位于不同行不同列的n个数的乘积，并冠以符号(-1)^t^，得到形如<script type="math/tex">(-1)^{t}a_{1p_{1}}a_{2p_{2}}a_{3p_{3}}...a_{np_{n}}.(1)</script>其中p1,p2,p3…p n为自然数1,2,3,4…n的一个排列，t为这个排列的逆序数。将所有形如(1)式的所有项(n!项)的代数和<script type="math/tex">\sum(-1)^{t}a_{1p_{1}}a_{2p_{2}}a_{3p_{3}}...a_{np_{n}}</script>称为n阶行列式。</p><script type="math/tex; mode=display">D=\begin{bmatrix}a_{11} & a_{12} & ... & a_{1n} \\a_{21} & a_{22} & ... & a_{2n} \\...    &   ...  & ... & ...       \\a_{n1} & a_{n2} & ... & a_{nn} \\\end{bmatrix}</script><p>简称<script type="math/tex">det(a_{ij})</script>，其中<script type="math/tex">a_{ij}</script>为行列式D的(i , j)元。</p><blockquote><p>上三角行列式</p><p>对角行列式</p></blockquote><h1 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h1><p><strong>性质1：行列式与它的转置行列相等。</strong></p><p><strong>性质2：对换行列式的两行（列），行列式变号。</strong></p><blockquote><p>推论：如果行列式有两行（列）完全相同，则此行列式等于0。</p></blockquote><p><strong>性质3：行列式的某一行（列）中所有元素都乘同一个数K，等于用数K乘此行列式。</strong></p><blockquote><p>推论: 行列式中某一行（列）中的所有元素的公因子可以提到行列式记号的外面。</p></blockquote><p><strong>性质4：行列式中如果有两行（列）的元素成比例，则此行列式等于0。</strong></p><p><strong>性质5：若行列式的某一行（列）的元素都是两数之和，则D等于这两个行列式之和。</strong></p><p><strong>性质6：把行列式的某一行（列）的各个元素乘同一个数然后加到另一行（列）对应元素上，行列式不变。</strong>     </p><h1 id="行列式按行按列展开"><a href="#行列式按行按列展开" class="headerlink" title="行列式按行按列展开"></a>行列式按行按列展开</h1><p>在n阶行列式中，把(i,j)元a~ij~所在的第i行第j列划去后，留下的n-1阶行列式叫做(i,j)元a~ij~的余子式，记作<script type="math/tex">M_{ij}</script>；记<script type="math/tex">A_{ij}=(-1)^{i+j}M_{ij}</script>为代数余子式。</p><p><strong>引理 一个n阶行列式，如果其中第i行所有元素除(i,j)元a~ij~外都是0，那么这行列式等于aij与它的代数余子式的乘积。</strong></p><p><strong>定理2：行列式等于它的任一行（列）的各元素与对应的代数余子式成绩之和。</strong></p><blockquote><p>推论：行列式某一行（列）的元素与另一行（列）的对应元素的代数余子式乘积之和等于0。</p></blockquote>]]></content>
    
    
    <summary type="html">线性代数重要定理总结</summary>
    
    
    
    <category term="线性代数" scheme="http://example.com/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>矩阵</title>
    <link href="http://example.com/2022/01/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%9F%A9%E9%98%B5/"/>
    <id>http://example.com/2022/01/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%9F%A9%E9%98%B5/</id>
    <published>2022-01-16T15:10:31.580Z</published>
    <updated>2022-01-17T13:19:55.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>线性方程组和矩阵</li><li>矩阵的运算</li><li>逆矩阵</li><li>克拉默法则</li><li>矩阵分块法</li></ul></blockquote><span id="more"></span><h1 id="线性方程组和矩阵"><a href="#线性方程组和矩阵" class="headerlink" title="线性方程组和矩阵"></a>线性方程组和矩阵</h1><h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><h2 id="矩阵的定义"><a href="#矩阵的定义" class="headerlink" title="矩阵的定义"></a>矩阵的定义</h2><p><strong>定义1：有mxn个数aij(i=1,2,…,m;j=1,2,…,n)排成的m行n列的数表，称为m行n列的矩阵，简称mxn矩阵。</strong></p><blockquote><blockquote><p>实矩阵：元素为实数。</p><p>复矩阵：元素为复数。</p><p>n阶方阵\n阶矩阵：行数与列数都等于n。</p><p>对角阵（对角矩阵）：从左上角到右下角的直线（叫做对角线）以外的元素全为0的方阵。</p><p>两个矩阵行数、列数都相同时，就称它们是同型矩阵。</p></blockquote></blockquote><h1 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h1><h2 id="矩阵的加法"><a href="#矩阵的加法" class="headerlink" title="矩阵的加法"></a>矩阵的加法</h2><p><strong>定义2：设有两个mxn矩阵A=(<script type="math/tex">a_{ij}</script>)和B=(<script type="math/tex">b_{ij}</script>)，那么矩阵A与B的和记作A+B。 </strong></p><blockquote><p>对应位上的元素相加。</p><p>只有两个矩阵为同型矩阵时才能进行加法运算。</p><ul><li>A+B=B+A</li><li>(A+B)+C=A+(B+C)</li><li>A+(-A)=0</li></ul></blockquote><h2 id="矩阵的数乘运算"><a href="#矩阵的数乘运算" class="headerlink" title="矩阵的数乘运算"></a>矩阵的数乘运算</h2><p><strong>定义3：数λ与矩阵A的乘积记作λA或Aλ。</strong></p><blockquote><ul><li>(λξ)A=λ(ξA)</li><li>(λ+ξ)A=λA+ξA</li><li>λ(A+B)=λA+λB</li></ul></blockquote><h2 id="矩阵与矩阵的乘法"><a href="#矩阵与矩阵的乘法" class="headerlink" title="矩阵与矩阵的乘法"></a>矩阵与矩阵的乘法</h2><p><strong>定义4：设A=(<script type="math/tex">a_{ij}</script>)是一个mxs的矩阵，B=(<script type="math/tex">b_{ij}</script>)是一个sxn的矩阵,那么规定矩阵A与矩阵B的乘积是一个mxn矩阵C=(<script type="math/tex">c_{ij}</script>) 。</strong></p><blockquote><ul><li>(AB)C=A(BC)</li><li>λ(AB)=(λA)B</li><li>A(B+C)=AB+AC</li></ul></blockquote><p><strong>矩阵相乘的几何意义：两个线性变换的相继作用。</strong></p><h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><p><strong>定义5：把矩阵A的行列式换成同序数的列得到一个新矩阵，叫做A的转置矩阵，记作A^T^</strong></p><blockquote><ul><li>(A^T^)^T^=A</li><li>(A+B)^T^=A^T^+B^T^</li><li>(λA)^T^=λA^T^</li><li>(AB)^T^=B^T^A^T^</li></ul><p>如果$$A^T^=A，那么A称为对称矩阵，简称对称阵。</p></blockquote><h2 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h2><p><strong>定义6：由n阶矩阵A的元素所构成的行列式（各元素的位置不变），称为方阵A的行列式，记作detA或|A|。</strong></p><blockquote><ul><li>|A^T^|=|A|</li><li>|λA|=λ^n^|A|</li><li>|AB|=|A||B|</li><li>|AB|=|BA|</li></ul></blockquote><h3 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h3><p>定义：行列式|A|的各个元素的代数余子式A~ij~所构成的如下矩阵，称为矩阵A的伴随矩阵，简称伴随阵。</p><p><strong>AA^<em>^=A^</em>^A=|A|E</strong></p><h1 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h1><h2 id="逆矩阵的定义、性质和求法"><a href="#逆矩阵的定义、性质和求法" class="headerlink" title="逆矩阵的定义、性质和求法"></a>逆矩阵的定义、性质和求法</h2><p><strong>定义7：对于n阶矩阵A，如果有一个n阶矩阵B，使AB=BA=E，则说矩阵A是可逆的，并把B称为A的逆矩阵，简称逆阵。</strong>(B^-1^AB=A)</p><p>如果A是可逆的，那么A的逆矩阵是唯一的。</p><p>定理1：若矩阵A可逆，则|A|$\neq$0.</p><p>定理2：若|A|$\neq$0,则矩阵A可逆，且$A^{-1}=\frac{1}{|A|}A^{*}$ </p><p>当|A|为0时，称A为奇异矩阵，|A|不为0时，称A为非奇异矩阵。矩阵A可逆的充要条件为|A|$\neq$0，即可逆矩阵为非奇异矩阵。</p><blockquote><p>推论：若AB=E或（BA=E），则B=A^-1^.</p><p><strong>逆矩阵的运算规律：A,B可逆</strong></p><script type="math/tex; mode=display">\begin{array}&(A^{-1})^{-1}=A\\(λA)^{-1}=\frac{1}{λ}A^{-1}\\(AB)^{-1}=B^{-1}A^{-1}\end{array}</script></blockquote><h1 id="克拉默法则"><a href="#克拉默法则" class="headerlink" title="克拉默法则"></a>克拉默法则</h1><p><strong>如果线性方程组的系数矩阵的行列式不为0，那么方程组有唯一解</strong></p><blockquote><p>AX=B</p><p>系数矩阵A行列式为0时，线性变换后将向量空间压缩到一维，方程组有无穷多解或无解；</p><p>系数矩阵A行列式不为0，线性变换后向量空间维度不变，方程组有唯一解</p></blockquote><h1 id="矩阵分块法"><a href="#矩阵分块法" class="headerlink" title="矩阵分块法"></a>矩阵分块法</h1><hr><h1 id="矩阵的初等变换"><a href="#矩阵的初等变换" class="headerlink" title="矩阵的初等变换"></a>矩阵的初等变换</h1><p><strong>定义1 矩阵的初等行变换</strong></p><blockquote><ul><li>对换两行</li><li>以数K$\neq$0乘某一行中的所有元</li><li>把某一行所有元的k倍加到另一行对应的元上去</li></ul><p>矩阵之间的等价关系具有以下性质</p><ul><li>反身性    A~A</li><li>对称性   若A~B,则 B~A</li><li>传递性   若A~B, B~C, 则A~C</li></ul><p>行最简形矩阵：行阶梯形矩阵非零行的第一个非零元为1，阶梯口元素所在其他元素为0.</p><p>标准形矩阵：左上角是单位阵，其它元素皆为0。</p><p>矩阵初等行变换的应用：</p><script type="math/tex; mode=display">\begin{array}&1.(A|E)\Rightarrow(E,A^{-1})   \\ 2.若AX=B,求X:(A|B)\Rightarrow(E|A^{-1}B)         \\3.求A^{-1}B：(A|B)\Rightarrow(E|A^{-1}B) \\4.求R(A)\end{array}</script></blockquote><p><strong>定义2：（1）非零矩阵若满足（i）非零行在零行上面；（ii）非零行的首非零元所在列在上一行（如果存在的话）的首非零元所在列的右边，则称此矩阵为行阶梯形矩阵；（2）若A是行阶梯形矩阵，并且还满足：（i）非零行的首非零元为1；（ii）首非零元所在的列其他元均为0，则称A为行最简形矩阵。</strong></p><p><strong>定理1：设A与B为mxn矩阵，那么</strong></p><p><strong>（i）（r）A~B的充分必要条件是存在m阶可逆矩阵P，使PA=B;</strong></p><p><strong>（ii）（c）A~B的充分必要条件是存在n阶可逆矩阵Q，使AQ=B</strong></p><p><strong>（iii）A~B的充分必要条件是存在m阶可逆矩阵P及可逆矩阵Q，使PAQ=B</strong></p><p><strong>定义3：由单位矩阵E经过一次初等行变换得到的矩阵称为初等矩阵。</strong></p><p><strong>性质1：设A是一个mxn矩阵，对A实施一次初等行变换，相当于在A的左边乘相应的m阶初等矩阵；对A施行一次初等列变换，相当于在A的右边乘相应的n阶初等矩阵。</strong></p><p><strong>性质2：方阵A可逆的充分必要条件是存在有限个初等矩阵P1,P2,P3,…Pn,使A=P1P2P3…Pn</strong></p><blockquote><p>n阶可逆矩阵的行最简形矩阵是n阶方阵。</p><p>推论：方阵A可逆的充分必要条件是A~rE</p></blockquote><h1 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h1><p><strong>定义4：在mxn矩阵A中，任取k行k列</strong>($k \leq m, k\leq n$) <strong>,位于这些交叉处的k^2^个元素，不改变它们在A中所处的位置次序而得到的k阶行列式，称为矩阵A的k阶子式。</strong>  </p><p><strong>引理：设A~rB，则A与B中的非零子式的最高阶数相等。</strong></p><p><strong>定义5：设在矩阵A中有一个不等于0的r阶子式D，且所有r+1阶子式（如果存在的话）全等于0，那么D称为矩阵A的最高阶子式，数r称为矩阵A的秩，记作R（A）。并规定零矩阵的秩为0.</strong></p><blockquote><p>可逆矩阵又称满秩矩阵，不可逆矩阵（奇异矩阵）又称降秩矩阵。</p></blockquote><p><strong>定理2：若A~B，则R(A)=R(B). </strong></p><blockquote><p>推论：若可逆矩阵P、Q使PAQ=B，则R(A)=R(B).</p></blockquote><p>矩阵的秩的性质：</p><script type="math/tex; mode=display">\begin{array}&1.\leq R(A_{mxn})\leq min\{ m, n\} \\2.R(A^{T})=R(A)\\3.若A \backsim B，则R(A)=R(B).\\4.若P，Q可逆，则R(PAQ)=R(A)\\5.max\{R(A),R(B)\}\leq R(A,B) \leq R(A)+R(B)\\特别地，当B=b，    R(A)\leq R(A,b)\leq R(A)+1\\6.R(A+B)\leq R(A)+R(B)\\7.R(AB)\leq min\{R(A),R(B)\}\\8.若A_{mxn}B_{nxl}=0,则R(A)+R(B)\leq n\end{array}</script><blockquote><p>列满秩矩阵：矩阵的秩等于等于它的列数。</p><p>行满秩矩阵：矩阵的秩等于它的行数。</p></blockquote><p><strong>秩的几何意义：秩即线性变换后空间的维度，是列空间的维数</strong></p><h1 id="线性方程组的解"><a href="#线性方程组的解" class="headerlink" title="线性方程组的解"></a>线性方程组的解</h1><p><strong>定理3：n元线性方程组Ax=b</strong></p><ol><li>无解的充分必要条件是R(A)&lt;R(A,b)</li><li>有唯一解的充分必要条件是R(A)=R(A,b)=n(维度不变)</li><li>有无限多解的充分必要条件是R(A)=R(A,b)&lt;n</li></ol><blockquote><script type="math/tex; mode=display">\begin{array}&1.|A|\neq 0 \Rightarrow R(A)=n\Rightarrow R(A,b)=n\Rightarrow Ax=b有解  \\2.|A|=0\Rightarrow R(A)<n\Rightarrow Ax=b无解or无穷多解\end{array}</script></blockquote><p><strong>定理4：n元齐次方程组Ax=0有非零解的充分必要条件是R(A)&lt;n;</strong></p><p><strong>定理5：线性方程组Ax=b有解的充分必要条件是R(A)=R(A,b) </strong></p><p><strong>定理6：矩阵方程AX=B有解的充分必要条件是R(A)=R(A,B) </strong></p><p>定理7：设AB=C，则$R(C)\leq min\{R(A),R(B) \}$ </p>]]></content>
    
    
    <summary type="html">线性代数重要定理总结</summary>
    
    
    
    <category term="线性代数" scheme="http://example.com/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
</feed>
