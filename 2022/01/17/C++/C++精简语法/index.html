<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="C++基础语法，《C++ Prime Plus》（第6版）读书笔记，待完善">
<meta property="og:type" content="article">
<meta property="og:title" content="C++基础知识">
<meta property="og:url" content="http://example.com/2022/01/17/C++/C++%E7%B2%BE%E7%AE%80%E8%AF%AD%E6%B3%95/index.html">
<meta property="og:site_name" content="Main">
<meta property="og:description" content="C++基础语法，《C++ Prime Plus》（第6版）读书笔记，待完善">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-01-16T16:05:55.387Z">
<meta property="article:modified_time" content="2022-02-25T14:01:20.610Z">
<meta property="article:author" content="SuPeng">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="编程语言">
<meta property="article:tag" content="高级语言">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/01/17/C++/C++%E7%B2%BE%E7%AE%80%E8%AF%AD%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++基础知识 | Main</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Main" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Main</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">悟已往之不谏，知来者之可追!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/SuPeng-Git" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/17/C++/C++%E7%B2%BE%E7%AE%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="SuPeng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Main">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++基础知识
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-17 00:05:55" itemprop="dateCreated datePublished" datetime="2022-01-17T00:05:55+08:00">2022-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-25 22:01:20" itemprop="dateModified" datetime="2022-02-25T22:01:20+08:00">2022-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <div class="post-description">C++基础语法，《C++ Prime Plus》（第6版）读书笔记，待完善</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="引用变量：-amp"><a href="#引用变量：-amp" class="headerlink" title="引用变量：&amp;"></a>引用变量：&amp;</h1><p><strong>创建引用声明：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType &amp; name = variate;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：必须在声明引用变量时进行初始化。</strong></p>
</blockquote>
<p><strong>将引用用作函数参数——按引用传递</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值	函数名(ElementType &amp; name,ElementType &amp; name)&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>临时变量 、引用参数和const</strong></p>
<blockquote>
<p>如果引用参数是const，则编译器将在下面两种情况下生成<strong>临时变量</strong>：</p>
<ol>
<li>实参的类型正确，但不是左值</li>
<li>实参的类型不正确，但可以转换为正确的类型</li>
</ol>
<p>注意：如果函数调用的参数不是左值或与之对应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，<br>将函数调用的参数的值传递给匿名变量，并让参数来引用该变量。</p>
<p><strong>尽可能使用const</strong></p>
<ol>
<li>使用const可以避免无意中修改数据的变长错误；</li>
<li>使用const使函数能够处理const和非const实参，否则将只能接受非const数据；</li>
<li>使用const引用使函数能够正确生成并使用临时变量。</li>
</ol>
</blockquote>
<p><strong>返回引用</strong></p>
<blockquote>
<p>返回引用的函数实际上是被引用的变量的别名。<br>返回引用应避免返回函数终止时不再存在的内存单元引用。<br>为避免这种问题，可以考虑返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用也指向这些数据。<br>另一种方法是用new类分配新的存储空间。但在不再需要new分配内存时，用使用delete来释放它们。<br>返回const引用—即不可修改的左值</p>
</blockquote>
<p><strong>何时使用引用参数</strong></p>
<blockquote>
<p>使用引用参数的主要原因：<br>程序员能够修改调用的函数中的数据对象<br>通过传递引用而不是整个数据对象，可以提高程序的运行速度。</p>
</blockquote>
<p>对于使用传递的值而不做修改的函数：</p>
<ul>
<li>如果数据对象很小，若内置数据类型或小型结构，则按值传递</li>
<li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。</li>
<li>如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省赋值结构所需的时间和空间。</li>
<li>如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。</li>
</ul>
<p>对于修改调用函数中数据的函数:</p>
<ul>
<li>如果数据对象是内置数据类型，则使用指针。</li>
<li>如果数据对象是数组，则只能使用指针。</li>
<li>如果数据对象是结构，则使用引用或指针。</li>
<li>如果数据对象是类对象，则使用引用。</li>
</ul>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p><strong>默认参数</strong>：指的是当函数调用中省略了实参时自动使用的一个值。</p>
<p><strong>默认参数的设置</strong></p>
<p>将默认值赋给原型中的参数。只有原型包含默认值的信息,函数定义无需修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[返回值类型] [函数名](ElementType _val = [默认值]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li>在函数调用中，实参按从左往右的顺序依次被赋给形参，而不能跳过任何参数。</li>
<li>如果某个位置有了默认参数，那么从这个位置往后都要有默认值。即只能在参数列表中从右到左提供默认参数。因此，如果为某个参数提供了默认值，则必须为该参数右边所有的参数提供默认值。</li>
</ul>
</blockquote>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>函数多态是C++在C语言基础上新增的功能。默认参数允许使用不同数目的参数调用同一个函数，而函数多态（函数重载）允许使用多个同名的函数。</p>
<p>术语“多态”指的是有多种形式，因此函数多态允许函数可以有多种形式。术语“函数重载”指的是可以有多个同名的函数，第名称进行了重载。</p>
<p>函数重载的关键是函数的参数列表——也称为函数的特征标。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。</p>
<p>注意：类型引用和类型本身视为同一特征标。</p>
<p><strong>何时使用函数重载</strong>：仅当函数基本上执行相同的任务，但使用不同形式的数据时使用函数重载。</p>
<blockquote>
<p>拓展：名称修饰</p>
<p>C++编译器执行一些神奇的操作——名称修饰或名名称矫正，它根据函数原型中指定的形参类型对每个函数进行加密。</p>
</blockquote>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p><strong>函数模板</strong>：函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。</p>
<p><strong>建立函数模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;</span><br><span class="line">[返回值类型] [函数名](AnyType a, AnyType b)&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行指出，要建立一个函数模板，并将类型命名为AnyType。类型名可以自定义，但要遵守C++命名规范。关键字template和typename是必需的。在标准C++98添加关键字typename之前，C++使用关键字class来创建模板。</p>
<p><strong>提示</strong>：如果需要多个将同一种算法用于不同类型的函数，则使用模板。如果不考虑向后兼容的问题，并愿意键入较长的单词，则声明类型参数时，应使用typename而不使用class。</p>
<p><strong>函数模板重载</strong></p>
<p>和常规函数重载相同，被重载的模板的函数特征标必须不同。</p>
<p><strong>模板的局限性</strong></p>
<p>编写的模板函数很可能无法处理某些类型。</p>
<p><strong>显示具体化</strong></p>
<p>当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。</p>
<ul>
<li>第三代具体化（ISO/ANSI C++标准）</li>
</ul>
<p>对于给定的函数名，可以有非模板函数、模板函数和显示具体化模板函数以及它们的重载版本。<br>显示具体化的原型和定义应以template&lt;&gt;打头，并通过名称来指出类型。<br>具体化优先于常规模板，而非模板函数优先于具体化和常规化模板。</p>
<p><strong>实例化和具体化</strong></p>
<ul>
<li>模板实例：编译器使用模板为特定类型生成函数定义时，得到的是模板实例。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">0.2</span>;</span><br><span class="line">cout &lt;&lt; Add&lt;<span class="keyword">double</span>&gt;(x, x);  <span class="comment">//显示示例</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>(m , m); <span class="comment">//隐式实例化</span></span><br></pre></td></tr></table></figure>
<ul>
<li>具体化（specialization）：隐式实例化、显示实例化和显示实例化统称具体化。它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。</li>
</ul>
<blockquote>
<p>引用显示实例化后，必须使用新的语法——在声明中使用前缀template和template&lt;&gt;，以区分显示实例化和具体实例化。</p>
<p>警告：试图在同一文件（或转换单元）中使用同一种类型的显示实例化和显式具体化将出错。</p>
</blockquote>
<p><strong>编译器选择使用哪个函数版本</strong></p>
<ul>
<li>重载解析：C++通过已确立的策略来决定为函数调用使用哪一个函数定义的过程称为重载解析。</li>
</ul>
<blockquote>
<ol>
<li>第一步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。</li>
<li>第二部：使用候选函数列表创建可行函数。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包含实参类型与相应的形参类型完全的情况。</li>
<li>第三步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。</li>
</ol>
</blockquote>
<ol>
<li>完全匹配和最佳匹配</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>从实参</th>
<th>到形参</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type</td>
<td>Type &amp;</td>
</tr>
<tr>
<td>Type &amp;</td>
<td>Type</td>
</tr>
<tr>
<td>Type []</td>
<td>*Type</td>
</tr>
<tr>
<td>Type (argument)</td>
<td>Type * (argument)</td>
</tr>
<tr>
<td>Type</td>
<td>const Type</td>
</tr>
<tr>
<td>Type</td>
<td>volatile Type</td>
</tr>
<tr>
<td>Type*</td>
<td>const Type</td>
</tr>
<tr>
<td>Type*</td>
<td>volatile Type*</td>
</tr>
</tbody>
</table>
</div>
<p>如果有多个匹配的原型，则编译器将无法完成重载解析过程；如果没有最佳的可行函数，则编译器将生成一条错误消息，该消息可能会使用诸如“ambiguous（二义性）”这样的词语。然而，有时候，即使两个函数都完全匹配，仍可完成重载解析。首先，指向非const数据的指针和引用优先与非const指针和引用参数匹配。const和非const之间的区别只适用于指针和引用指向的数据。</p>
<p>一个完全匹配优于另一个的另一种情况是，其中一个时非模板函数，而另一个不是。在这种情况下，非模板函数优先于模板函数（包括显式具体化）。具体化优先于常规模板，而非模板函数优先于具体化和常规化模板。</p>
<p>如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先。例如，这意味着显式具体化将优于使用模板隐式生成的具体化。</p>
<p>术语“最具体（most specialized）”并不一定意味着显式具体化，而是指编译器推断使用哪种类型时执行的转换最少。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="function"><span class="keyword">void</span> <span class="title">recycle</span> <span class="params">(Type t)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="function"><span class="keyword">void</span> <span class="title">recycle</span> <span class="params">(Type * t)</span></span>; <span class="comment">// #2</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blot</span> &#123;</span><span class="keyword">int</span> a; <span class="keyword">char</span> b[<span class="number">10</span>];&#125;;</span><br><span class="line">blot ink = &#123;<span class="number">25</span>, <span class="string">&quot;spots&quot;</span>&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">recycle</span>(&amp;ink); <span class="comment">// address of a structure</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>recycle(&amp;ink)调用与#1模板匹配，匹配时将Type解释为blot <em>。recycle(&amp;ink)函数调用也与#2模板匹配，这次Type被解释为blot。因此将两个隐式实例——recycle&lt;blot </em>&gt;(blot <em>)和recycle <blot>(blot </em>)发送到可行函数池中。<br>在这两个模板函数中，recycle<blot *>(blot *)被认为是更具体的，因为在生成过程中，它需要进行的转换更少。也就是说，#2模板已经显式指出，函数参数是指向Type的指针，因此可以直接用blot标识Type；而#1模板将Type作为函数参数，因此Type必须被解释为指向blot的指针。也就是说，在#2模板中，Type已经被具体化为指针，因此说它“更具体”。</p>
</blockquote>
<p>用于找出最具体的模板的规则被称为函数模板的部分排序规则（partial ordering rules）。和显式实例一样，这也是C++98新增的特性。</p>
<ol>
<li>创建自定义选择</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[函数名]&lt;&gt;([实参]);</span><br><span class="line"><span class="comment">// &lt;&gt;指出，编译器应选择模板函数，而不是非模板函数；</span></span><br><span class="line">[函数名]&lt;类型&gt;([实参]);</span><br><span class="line"><span class="comment">// &lt;类型&gt;要求进行显示实例化</span></span><br></pre></td></tr></table></figure>
<p><strong>关键字decltype（C++11）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression) var;<span class="comment">// make var the same type as x;</span></span><br></pre></td></tr></table></figure>
<p>给decltype提供的参数可以是表达式、标识符。</p>
<ul>
<li>如果expression是一个没有用括号括起的标识符，则var的类型与该标识符的类型相同，包括const等限定符。</li>
<li>如果expression是一个函数调用，则var的类型与函数的返回类型相同。</li>
<li>如果expression是一个左值，则var为指向其类型的引用。expression是用括号括起的标识符。</li>
<li>如果前面的条件都不满足，则var的类型与expression的类型相同</li>
</ul>
<blockquote>
<p>注意：<br>给decltype提供的参数是表达式时，并不会调用函数。编译器通过查看函数的原型来获悉返回类型，而无需调用函数。<br>括号并不会改变表达式的值和左值性。</p>
</blockquote>
<p><strong>另一种函数声明语法——C++11后置返回类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">gt</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将返回类型移到了参数声明后面。-&gt;double被称为后置返回类型（trailing return type）。其中auto是一个占位符，表示后置返回类型提供的类型，这是C++11给auto新增的一种角色。这种语法也可用于函数定义.</p>
<h1 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h1><h2 id="传统的C-名称空间"><a href="#传统的C-名称空间" class="headerlink" title="传统的C++名称空间"></a>传统的C++名称空间</h2><p><strong>声明区域（declaration）</strong>：声明区域是可以在其中进行声明的区域。</p>
<p><strong>潜在作用域（potential scope）</strong>：变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。</p>
<p><strong>作用域（scope）</strong>：变量对程序而言可见的范围被称为作用域。</p>
<blockquote>
<p>变量并非在其潜在作用域内的任何位置都是可见的。例如，它可能被另一个在嵌套声明区域中声明的同名变量隐藏。例如，在函数中声明的局部变量（对于这种变量，声明区域为整个函数）将隐藏在同一个文件中声明的全局变量（对于这种变量，声明区域为整个文件）。</p>
</blockquote>
<p>C++关于全局变量和局部变量的规则定义了一种名称空间层次。每个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的名称。在一个函数中声明的局部变量不会与在另一个函数中声明的局部变量发生冲突。</p>
<h2 id="新的空间特性"><a href="#新的空间特性" class="headerlink" title="新的空间特性"></a>新的空间特性</h2><p>C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。</p>
<p>名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。</p>
<p><strong>全局空间</strong>：除了用户定义的名称空间外，还存在另一个名称空间——全局名称空间（global namespace）。它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中。</p>
<p>任何名称空间中的名称都不会与其他名称空间中的名称发生冲突。</p>
<p>未被装饰的名称（如pail）称为未限定的名称（unqualified name）；包含名称空间的名称（如Jack::pail）称为限定的名称（qualified name）。</p>
<h3 id="using声明和using编译"><a href="#using声明和using编译" class="headerlink" title="using声明和using编译"></a>using声明和using编译</h3><p>using声明使特定的标识符可用，using编译指令使整个名称空间可用。</p>
<p><strong>using声明</strong>：using声明由被限定的名称和它前面的关键字using组成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Jill::fetch; <span class="comment">// a using declaration</span></span><br></pre></td></tr></table></figure>
<p>using声明将特定的名称添加到它(using声明)所属的声明区域中。</p>
<p><strong>using编译</strong>：using声明使一个名称可用，而using编译指令使所有的名称都可用。using编译指令由名称空间名和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Jack; <span class="comment">// make all the names in Jack available</span></span><br></pre></td></tr></table></figure>
<p>使用using编译和using声明增加了名称冲突的可能，存在二义性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jack::pal = <span class="number">3</span>;</span><br><span class="line">jill::pal =<span class="number">10</span>;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">using</span> jack::pal;</span><br><span class="line"><span class="keyword">using</span> jill::pal;</span><br><span class="line">pal = <span class="number">4</span>;       <span class="comment">// which one? now have a conflict</span></span><br></pre></td></tr></table></figure>
<h3 id="using编译指令和using声明之比较"><a href="#using编译指令和using声明之比较" class="headerlink" title="using编译指令和using声明之比较"></a>using编译指令和using声明之比较</h3><p>如果某个名称已经在函数中声明了，则不能用using声明导入相同的名称。如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。</p>
<blockquote>
<p>注意：<br>假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，则这两个名称会发生冲突，从而出错。如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。</p>
</blockquote>
<h3 id="名称空间的其他特性"><a href="#名称空间的其他特性" class="headerlink" title="名称空间的其他特性"></a>名称空间的其他特性</h3><p><strong>可嵌套</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> elements</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> fire</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flame;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> water;</span><br><span class="line">&#125;   <span class="comment">//无分号;</span></span><br></pre></td></tr></table></figure>
<p><strong>*using编译指令的传递性</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myth</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Jill::fetch;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> elements;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::cin;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> myth;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> myth;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> elements;</span><br><span class="line"><span class="comment">// 与using namespace myth;等价</span></span><br></pre></td></tr></table></figure>
<p><strong>名称空间的别名</strong><br>可以给名称空间创建别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MH = myth;</span><br></pre></td></tr></table></figure>
<p><strong>未命名的名称空间</strong><br>可以通过省略名称空间的名称来创建未命名的名称空间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="comment">// unnamed namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ice;</span><br><span class="line">    <span class="keyword">int</span> bandycoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这种名称空间没有名称，因此不能显式地使用using编译指令或using声明来使它在其他位置都可用。具体地说，不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称。这提供了链接性为内部的静态变量的替代品。</p>
<p><strong>关于名称空间的使用规范</strong></p>
<blockquote>
<ul>
<li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</li>
<li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</li>
<li>如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++当前提倡将标准函数库放在名称空间std中，这种做法扩展到了来自C语言中的函数。例如，头文件math.h是与C语言兼容的，没有使用名称空间，但C++头文件cmath应将各种数学库函数放在名称空间std中。实际上，并非所有的编译器都完成了这种过渡。</li>
<li>仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。</li>
<li>不要在头文件中使用using编译指令。这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include之后。</li>
<li>导入名称时，首选使用作用域解析运算符或using声明的方法。</li>
<li>对于using声明，首选将其作用域设置为局部而不是全局。</li>
</ul>
</blockquote>
<h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><h2 id="抽象和类"><a href="#抽象和类" class="headerlink" title="抽象和类"></a>抽象和类</h2><p><strong>类</strong>：类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。</p>
<p><strong>接口</strong>：接口是一个共享框架，供两个系统（如在计算机和打印机之间或者用户或计算机程序之间）交互时使用。</p>
<p>通常，C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码文件中。这里采用这种典型做法。</p>
<p><strong>访问控制</strong>：关键字private、public和protect描述了对类成员的访问控制。使用类对象的程序都可以直接访问共有部分，但只能通过共有成员函数或友元函数来访问私有对象。</p>
<p>类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽象组件。将实现细节放在一起并将它们与抽象分开被称为封装。数据隐藏（将数据放在类的私有部分中）是一种封装，将实现的细节隐藏在私有部分中，也是一种封装。封装的另一个例子是，将类函数定义和类声明放在不同的文件中。</p>
<p><strong>实现类成员函数</strong></p>
<p>创建类描述的第二部分：为那些由类声明中的原型表示的成员函数提供代码。成员函数定义与常规函数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：</p>
<ul>
<li>定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类；</li>
<li>类方法可以访问类的private组件。</li>
</ul>
<p><strong>内联方法</strong></p>
<p>其定义位于类声明中的函数都将自动成为内联函数；如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。为此，只需在类实现部分中定义函数时使用inline限定符即可。</p>
<p>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用的、最简便的方法是：将内联定义放在定义类的头文件中（有些开发系统包含智能链接程序，允许将内联定义放在一个独立的实现文件）。</p>
<p>根据改写规则（rewrite rule），在类声明中定义方法等同于用原型替换方法定义，然后在类声明的后面将定义改写为内联函数。</p>
<p><strong>类的声明</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    data member declarations</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    member function prototypes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类声明类似结构声明，可以包括数据成员和函数成员。声明有私有部分，在其中声明的成员只能通过成员函数进行访问；声明还具有公有部分，在其中声明的成员可被使用类对象的程序直接访问。通常，数据成员被放在私有部分中，成员函数被放在公有部分中.</p>
<p>公有部分的内容构成了设计的抽象部分——公有接口。将数据封装到私有部分中可以保护数据的完整性，这被称为数据隐藏。因此，C++通过类使得实现抽象、数据隐藏和封装等OOP特性很容易。</p>
<p><strong>实现类成员函数</strong></p>
<p>可以在类声明中提供完整的函数定义，而不是函数原型，但是通常的做法是单独提供函数定义（除非函数很小）。在这种情况下，需要使用作用域解析运算符来指出成员函数属于哪个类。例如，假设Bozo有一个名为Retort()的成员函数，该函数返回char指针，则其函数头如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Bozo::Retort</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<p>静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员是const整数类型或枚举型，则可以在类声明中初始化。</p>
</blockquote>
<h2 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h2><p>构造函数是一种特殊的类成员函数，在创建类对象时被调用。另外，构造函数没有声明类型。</p>
<p><strong>使用构造函数</strong></p>
<p>C++提供了两种使用构造函数来初始化对象的方式。第一种方式是显式地调用构造函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock s1 = <span class="built_in">stock</span>(...);</span><br></pre></td></tr></table></figure>
<p>另一种方式是隐式地调用构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stock <span class="title">s1</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="comment">// 等价于stock s1 = stock(...);</span></span><br></pre></td></tr></table></figure>
<p>每次创建类对象（甚至使用new动态分配内存）时，C++都使用类构造函数。下面是将构造函数与new一起使用的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock *p_stock = <span class="keyword">new</span> <span class="built_in">stock</span>(...);</span><br></pre></td></tr></table></figure>
<p><strong>默认构造函数</strong>：默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。如果没有提供任何构造函数，则C++将自动提供默认构造函数。它是默认构造函数的隐式版本，不做任何工作。</p>
<blockquote>
<p>同理可得，非默认构造函数是提供了显示初始化值来创建对象的构造函数</p>
</blockquote>
<p>当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造函数。如果提供了非默认构造函数（如Stock(const char * co, int n, double pr)），但没有提供默认构造函数，则下面的声明将出错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock stock1; <span class="comment">// not possible with current constructor</span></span><br></pre></td></tr></table></figure>
<p>如果要创建对象，而不显式地初始化，则必须定义一个不接受任何参数的默认构造函数。定义默认构造函数的方式有两种。一种是给已有构造函数的所有参数提供默认值。另一种方式是通过函数重载来定义另一个构造函数—— 一个没有参数的构造函数。</p>
<p>由于只能有一个默认构造函数，因此不要同时采用这两种方式。实际上，通常应初始化所有的对象，以确保所有成员一开始就有已知的合理值。因此，用户定义的默认构造函数通常给所有成员提供隐式初始值。</p>
<blockquote>
<p>提示：　<br>在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数。<br>隐式地调用默认构造函数时，不要使用圆括号。<br>如果既可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化方式。通常这种方式的效率更高。</p>
<p>警告：<br>接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Classname object = value;</span><br></pre></td></tr></table></figure>
<p><strong>析构函数</strong></p>
<p>用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。对象过期时，程序将自动调用一个特殊的成员函数，该函数的名称令人生畏——析构函数。析构函数完成清理工作，因此实际上很有用。</p>
<p>和构造函数一样，析构函数的名称也很特殊：在类名前加上~。</p>
<p>如果程序创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用。如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用。最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。</p>
<p>由于在类对象过期时析构函数将自动被调用，因此必须有一个析构函数。如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除的代码后，提供默认析构函数的定义。</p>
<p><strong>C++11列表初始化</strong></p>
<p>在C++11中，可将列表初始化语法用于类，只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stock hot_tip = &#123;...&#125;;</span><br><span class="line">stock jock &#123;...&#125;;</span><br><span class="line">stock temp &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>const成员函数</strong>：一种保证函数不会被修改调用对象的新语法。</p>
<p>const成员函数是在成员函数的基础上将const关键字放在函数的括号后面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[返回值类型] [函数名]() <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// const成员函数定义</span></span><br><span class="line">[返回值类型] [函数名]() <span class="keyword">const</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>一般来说，所有的类方法都将this指针设置为调用它的对象的地址。</p>
<p>每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象。如果方法需要引用整个调用对象，则可以使用表达式*this。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。</p>
<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数初始化</span></span><br><span class="line">Classname object[numbers];</span><br><span class="line"><span class="comment">// 构造函数初始化</span></span><br><span class="line">Classname object[numbers] = &#123;</span><br><span class="line">    <span class="built_in">Classname</span>(...),</span><br><span class="line">    <span class="built_in">Classname</span>(...),</span><br><span class="line">    ....</span><br><span class="line">    <span class="built_in">Classname</span>(...),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有默认构造函数。</p>
<h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><blockquote>
<p>C++类引入了一种新的作用域：类作用域。</p>
</blockquote>
<p>在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。也就是说，要调用公有成员函数，必须通过对象。</p>
<p><strong>作用域为类的常量</strong></p>
<p>第一种方式是在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>Months = <span class="number">12</span>&#125;; <span class="comment">//由于这里使用枚举只是为了创建符号常量，并不打算创建枚举类型的变量，因此不需要提供枚举名。</span></span><br><span class="line">    <span class="keyword">double</span> costs[Months];</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>注意，用这种方式声明枚举并不会创建类数据成员。也就是说，所有对象中都不包含枚举。另外，Months只是一个符号名称，在作用域为整个类的代码中遇到它时，编译器将用12来替换它。</p>
<p>C++提供了另一种在类中定义常量的方式——使用关键字static：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;   <span class="comment">//静态类成员</span></span><br><span class="line">    <span class="keyword">double</span> costs[Months];</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这将创建一个名为Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。因此，只有一个Months常量，被所有Bakery对象共享。</p>
<p><strong>作用域内枚举（C++11）</strong></p>
<p>C++11提供了一种新枚举，其枚举量的作用域为类。这种枚举的声明类似于下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">name</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="comment">//  也可使用关键字struct代替class</span></span><br></pre></td></tr></table></figure>
<p>枚举量的作用域为类后，不同枚举定义中的枚举量就不会发生名称冲突。</p>
<p>C++11还提高了作用域内枚举的类型安全。在有些情况下，常规枚举将自动转换为整型，如将其赋给int变量或用于比较表达式时，但作用域内枚举不能隐式地转换为整型。但在必要时，可进行显式类型转换。</p>
<p>默认情况下，C++11作用域内枚举的底层类型为int。另外，还提供了一种语法，可用于做出不同的选择：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// underlying type for pizza is short</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> :</span> <span class="keyword">short</span> pizza &#123;Small, Medium, Large, XLarge&#125;;</span><br></pre></td></tr></table></figure>
<p>:short将底层类型指定为short。底层类型必须为整型。在C++11中，也可使用这种语法来指定常规枚举的底层类型，但如果没有指定，编译器选择的底层类型将随实现而异。</p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p><strong>栈</strong></p>
<ul>
<li>可创建空栈。</li>
<li>可将数据项添加到栈顶（压入）。</li>
<li>可从栈顶删除数据项（弹出）。</li>
<li>可查看栈否填满。</li>
<li>可查看栈是否为空。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack.h -- class definition for the stack ADT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> Item;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>MAX = <span class="number">10</span>&#125;; <span class="comment">// constant specific to class</span></span><br><span class="line">    Item items[MAX]; <span class="comment">// holds stack items</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">// index for top stack item</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// push() returns false if stack already is full, true otherwise</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Item &amp; item)</span></span>; <span class="comment">// add item to stack</span></span><br><span class="line">    <span class="comment">// pop() returns false if stack already is empty, true otherwise</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(Item &amp; item)</span></span>; <span class="comment">// pop top into item</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack.cpp -- Stack member functions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stack.h&quot;</span></span></span><br><span class="line">Stack::<span class="built_in">Stack</span>() <span class="comment">// create an empty stack</span></span><br><span class="line">&#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::isempty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::isfull</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="keyword">const</span> Item &amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        items[top++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::pop</span><span class="params">(Item &amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        item = items[--top];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h1><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载是一种形式的C++多态。</p>
<p>要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[classname]<span class="function"><span class="keyword">operator</span> <span class="title">op</span><span class="params">(argument-list)</span></span></span><br></pre></td></tr></table></figure>
<p>例如，operator +()重载+运算符，operator <em>()重载 </em>运算符。op必须是有效的C++运算符，不能虚构一个新的符号。</p>
<p><strong>重载限制</strong></p>
<ol>
<li>重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。因此，不能将减法运算符（−）重载为计算两个double值的和，而不是它们的差。虽然这种限制将对创造性有所影响，但可以确保程序正常运行。</li>
<li>使用运算符时不能违反运算符原来的句法规则。例如，不能修改运算符的优先级。因此，如果将加号运算符重载成将两个类相加，则新的运算符与原来的加号具有相同的优先级。</li>
<li>不能创建新运算符。</li>
<li>不能重载下面的运算符。</li>
</ol>
<blockquote>
<ul>
<li>sizeof：sizeof运算符。</li>
<li>.：成员运算符。</li>
<li>*：成员指针运算符。</li>
<li>::：作用域解析运算符。</li>
<li>?:：条件运算符。</li>
<li>typeid：一个RTTI运算符。</li>
<li>const_cast：强制类型转换运算符。</li>
<li>dynamic_cast：强制类型转换运算符。</li>
<li>reinterpret_cast：强制类型转换运算符。</li>
<li>static_cast：强制类型转换运算符。</li>
</ul>
</blockquote>
<p><strong>可重载运算符</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>+</th>
<th>-</th>
<th>*</th>
<th>/</th>
<th>%</th>
<th>^</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>\</td>
<td></td>
<td>~=</td>
<td>!</td>
<td>=</td>
<td>&lt;</td>
</tr>
<tr>
<td>&gt;</td>
<td>+=</td>
<td>-=</td>
<td>*=</td>
<td>/=</td>
<td>%=</td>
</tr>
<tr>
<td>^=</td>
<td>&amp;=</td>
<td>\</td>
<td>=</td>
<td>&lt;&lt;</td>
<td>&gt;&gt;</td>
<td>&gt;&gt;=</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>==</td>
<td>!=</td>
<td>&lt;=</td>
<td>&gt;=</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>++</td>
<td>—</td>
<td>,</td>
<td>-&gt;*</td>
<td>-&gt;</td>
</tr>
<tr>
<td>()</td>
<td>[]</td>
<td>new</td>
<td>delete</td>
<td>new[]</td>
<td>delete[]</td>
</tr>
</tbody>
</table>
</div>
<p>大多数运算符都可以通过成员或非成员函数来重载。一般来说，非成员函数应是友元函数，这样它才能直接访问类的私有数据。在定义运算符时，必须选择其中的一种格式，而不能同时选择这两种格式。因为这两种格式都与同一个表达式匹配，同时定义这两种格式将被视为二义性错误，导致编译错误。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元：C++提供的另一种访问类对象私有部分形式的访问权限。可将友元函数看作类的扩展接口的组成部分。</p>
<p>友元有3种：</p>
<ul>
<li>友元函数；</li>
<li>友元类；</li>
<li>友元成员函数。</li>
</ul>
<p><strong>友元函数</strong></p>
<p>通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。</p>
<p>用法示例：运算符通过非成员函数重载</p>
<p><strong>创建友元函数</strong></p>
<p>创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend。</p>
<ul>
<li>虽然友元函数函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；</li>
<li>虽然友元函数函数不是成员函数，但它与成员函数的访问权限相同。</li>
</ul>
<p>第二步是编写函数定义。因为它不是成员函数，所以不要使用Time::限定符。另外，不要在定义中使用关键字friend。</p>
<blockquote>
<p>提示：<br>如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以用友元函数来反转操作数的顺序。</p>
<p>警告：<br>只有在类声明中的原型中才能使用friend关键字。除非函数定义也是原型，否则不能在函数定义中使用该关键字。</p>
</blockquote>
<h2 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h2><p><strong>explicit关键字</strong>：关闭将构造函数用作自动类型转换函数的特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explicit</span> [构造函数](...);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>只接受一个参数的构造函数定义了从参数到类类型的转换。如果使用关键字explicit限定了这种构造函数，则它只能用于显示转换，否则可以用于隐式转换。</p>
</blockquote>
<p><strong>转换函数</strong>：从类类型转换到其它类型的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>转换函数必须是类方法；<br>转换函数不能指定返回类型；<br>转换函数不能有参数。</p>
<p>警告：<br>应谨慎地使用隐式转换函数。通常，最好选择仅在被显式地调用时才会执行的函数。</p>
</blockquote>
<p>总之，C++为类提供了下面的类型转换。</p>
<ul>
<li><p>只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。例如，将int值赋给Stonewt对象时，接受int参数的Stonewt类构造函数将自动被调用。然而，在构造函数声明中使用explicit可防止隐式转换，而只允许显式转换。</p>
</li>
<li><p>被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。转换函数是类成员，没有返回类型、没有参数、名为operator typeName()，其中，typeName是对象将被转换成的类型。将类对象赋给typeName变量或将其强制转换为typeName类型时，该转换函数将自动被调用。</p>
</li>
</ul>
<p><strong>转换函数和友元函数</strong></p>
<h1 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h1><p>静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。</p>
<p>静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员是const整数类型或枚举型，则可以在类声明中初始化。</p>
<h2 id="动态内存和类"><a href="#动态内存和类" class="headerlink" title="动态内存和类"></a>动态内存和类</h2><h3 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h3><p>C++自动提供了下面这些成员函数：</p>
<ul>
<li>默认构造函数，如果没有定义构造函数；</li>
<li>默认析构函数，如果没有定义；</li>
<li>复制构造函数，如果没有定义；</li>
<li>赋值运算符，如果没有定义；</li>
<li>地址运算符，如果没有定义。</li>
</ul>
<p>编译器将生成上述最后三个函数的定义——如果程序使用对象的方式要求这样做。</p>
<p>隐式地址运算符返回调用对象的地址（即this指针的值）。</p>
<p>默认析构函数不执行任何操作。</p>
<p>C++11提供了另外两个特殊成员函数：移动构造函数（move constructor）和移动赋值运算符（move assignment operator）。</p>
<h4 id="1．默认构造函数"><a href="#1．默认构造函数" class="headerlink" title="1．默认构造函数"></a>1．默认构造函数</h4><p>如果没有提供任何构造函数，C++将创建默认构造函数。例如，假如定义了一个Klunk类，但没有提供任何构造函数，则编译器将提供下述默认构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Klunk::<span class="built_in">Klunk</span>() &#123; &#125; <span class="comment">// implicit default constructor</span></span><br></pre></td></tr></table></figure>
<p>也就是说，编译器将提供一个不接受任何参数，也不执行任何操作的构造函数（默认的默认构造函数），这是因为创建对象时总是会调用构造函数：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Klunk lunk; <span class="regexp">//</span> invokes default constructor</span><br></pre></td></tr></table></figure>
<p>默认构造函数使lunk类似于一个常规的自动变量，也就是说，它的值在初始化时是未知的。</p>
<p>如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象时不显式地对它进行初始化，则必须显式地定义默认构造函数。这种构造函数没有任何参数，但可以使用它来设置特定的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Klunk::<span class="built_in">Klunk</span>() <span class="comment">// explicit default constructor</span></span><br><span class="line">&#123;</span><br><span class="line">    klunk_ct = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。例如，Klunk类可以包含下述内联构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Klunk</span>(<span class="keyword">int</span> n = <span class="number">0</span>) &#123; klunk_ct = n; &#125;</span><br></pre></td></tr></table></figure>
<p>但只能有一个默认构造函数。也就是说，不能这样做：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Klunk() &#123; klunk_ct = <span class="number">0</span> &#125;           <span class="regexp">//</span> constructor <span class="comment">#1</span></span><br><span class="line">Klunk(int n = <span class="number">0</span>) &#123; klunk_ct = n; &#125; <span class="regexp">//</span> ambiguous constructor <span class="comment">#2</span></span><br></pre></td></tr></table></figure>
<p>这为何有二义性呢？请看下面两个声明：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Klunk kar(<span class="number">10</span>); <span class="regexp">//</span> clearly matches Klunt(int n)</span><br><span class="line">Klunk bus;     <span class="regexp">//</span> could match either constructor</span><br></pre></td></tr></table></figure>
<p>第二个声明既与构造函数#1（没有参数）匹配，也与构造函数#2（使用默认参数0）匹配。这将导致编译器发出一条错误消息。</p>
<h4 id="2．复制构造函数"><a href="#2．复制构造函数" class="headerlink" title="2．复制构造函数"></a>2．复制构造函数</h4><p>复制构造函数用于将一个对象复制到新创建的对象中。也就是说，它用于初始化过程中（包括按值传递参数），而不是常规的赋值过程中。类的复制构造函数原型通常如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Class_name</span>(<span class="keyword">const</span> Class_name &amp;);</span><br></pre></td></tr></table></figure>
<p>对于复制构造函数，需要知道两点：何时调用和有何功能。</p>
<h4 id="3．何时调用复制构造函数"><a href="#3．何时调用复制构造函数" class="headerlink" title="3．何时调用复制构造函数"></a>3．何时调用复制构造函数</h4><p>新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有的对象。例如，假设motto是一个StringBad对象，则下面4种声明都将调用复制构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBad <span class="title">ditto</span><span class="params">(motto)</span></span>;  <span class="comment">// calls StringBad(const StringBad &amp;)</span></span><br><span class="line">StringBad metoo = motto; <span class="comment">// calls StringBad(const StringBad &amp;)</span></span><br><span class="line">StringBad also = <span class="built_in">StringBad</span>(motto);</span><br><span class="line">                         <span class="comment">// calls StringBad(const StringBad &amp;)</span></span><br><span class="line">StringBad * pStringBad = <span class="keyword">new</span> <span class="built_in">StringBad</span>(motto);</span><br><span class="line">                         <span class="comment">// calls StringBad(const StringBad &amp;)</span></span><br></pre></td></tr></table></figure>
<p>其中中间的2种声明可能会使用复制构造函数直接创建metoo和also，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metoo和also，这取决于具体的实现。最后一种声明使用motto初始化一个匿名对象，并将新对象的地址赋给pStringBad指针。</p>
<p>每当程序生成了对象副本时，编译器都将使用复制构造函数。具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。记住，按值传递意味着创建原始变量的一个副本。编译器生成临时对象时，也将使用复制构造函数。例如，将3个Vector对象相加时，编译器可能生成临时的Vector对象来保存中间结果。何时生成临时对象随编译器而异，但无论是哪种编译器，当按值传递和返回对象时，都将调用复制构造函数。</p>
<p>由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。</p>
<h4 id="4．默认的复制构造函数的功能"><a href="#4．默认的复制构造函数的功能" class="headerlink" title="4．默认的复制构造函数的功能"></a>4．默认的复制构造函数的功能</h4><p>默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值。</p>
<p>如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态成员（如num_strings）不受影响，因为它们属于整个类，而不是各个对象。</p>
<p>如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。复制的另一种形式（成员复制或浅复制）只是复制指针值。浅复制仅浅浅地复制指针信息，而不会深入“挖掘”以复制指针引用的结构。</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="　赋值运算符"></a>　赋值运算符</h3><p>ANSI C允许结构赋值，而C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的。这种运算符的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class_name &amp; Class_name::<span class="keyword">operator</span>=(<span class="keyword">const</span> Class_name &amp;);</span><br></pre></td></tr></table></figure>
<h4 id="1．赋值运算符的功能以及何时使用它"><a href="#1．赋值运算符的功能以及何时使用它" class="headerlink" title="1．赋值运算符的功能以及何时使用它"></a>1．赋值运算符的功能以及何时使用它</h4><p>将已有的对象赋给另一个对象时，将使用重载的赋值运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBad <span class="title">headline1</span><span class="params">(<span class="string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">StringBad knot;</span><br><span class="line">knot = headline1; <span class="comment">// assignment operator invoked</span></span><br></pre></td></tr></table></figure>
<p>这里，metoo是一个新创建的对象，被初始化为knot的值，因此使用复制构造函数。然而，正如前面指出的，实现时也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时对象的值复制到新对象中。这就是说，初始化总是会调用复制构造函数，而使用=运算符时也允许调用赋值运算符。</p>
<p>与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响。</p>
<h4 id="2．赋值的问题出在哪里"><a href="#2．赋值的问题出在哪里" class="headerlink" title="2．赋值的问题出在哪里"></a>2．赋值的问题出在哪里</h4><p>程序清单12.3将headline1赋给knot：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knot = headline1;</span><br></pre></td></tr></table></figure>
<p>为knot调用析构函数时，将显示下面的消息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Celery Stalks at Midnight&quot;</span> object deleted, <span class="number">2</span> left</span><br></pre></td></tr></table></figure>
<p>为Headline1调用析构函数时，显示如下消息（有些实现方式在此之前就异常终止了）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;-|&quot;</span> object deleted, <span class="number">-2</span> left</span><br></pre></td></tr></table></figure>
<p>出现的问题与隐式复制构造函数相同：数据受损。这也是成员复制的问题，即导致headline1.str和knot.str指向相同的地址。因此，当对knot调用析构函数时，将删除字符串“Celery Stalks at Midnight”；当对headline1调用析构函数时，将试图删除前面已经删除的字符串。正如前面指出的，试图删除已经删除的数据导致的结果是不确定的，因此可能改变内存中的内容，导致程序异常终止。要指出的是，如果操作结果是不确定的，则执行的操作将随编译器而异，包括显示独立声明（Declaration of Independence）或释放隐藏文件占用的硬盘空间。当然，编译器开发人员通常不会花时间添加这样的行为。</p>
<h4 id="3．解决赋值的问题"><a href="#3．解决赋值的问题" class="headerlink" title="3．解决赋值的问题"></a>3．解决赋值的问题</h4><p>对于由于默认赋值运算符不合适而导致的问题，解决办法是提供赋值运算符（进行深度复制）定义。其实现与复制构造函数相似，但也有一些差别。</p>
<ul>
<li>由于目标对象可能引用了以前分配的数据，所以函数应使用delete[ ]来释放这些数据。</li>
<li>函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容。</li>
<li>函数返回一个指向调用对象的引用。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag"># 编程语言</a>
              <a href="/tags/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80/" rel="tag"># 高级语言</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E8%A1%8C%E5%88%97%E5%BC%8F/" rel="prev" title="行列式">
      <i class="fa fa-chevron-left"></i> 行列式
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/19/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8/" rel="next" title="程序设计入门">
      程序设计入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%EF%BC%9A-amp"><span class="nav-number">1.</span> <span class="nav-text">引用变量：&amp;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">默认参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">3.</span> <span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.</span> <span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="nav-number">5.</span> <span class="nav-text">名称空间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84C-%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="nav-number">5.1.</span> <span class="nav-text">传统的C++名称空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E7%A9%BA%E9%97%B4%E7%89%B9%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">新的空间特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#using%E5%A3%B0%E6%98%8E%E5%92%8Cusing%E7%BC%96%E8%AF%91"><span class="nav-number">5.2.1.</span> <span class="nav-text">using声明和using编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E5%92%8Cusing%E5%A3%B0%E6%98%8E%E4%B9%8B%E6%AF%94%E8%BE%83"><span class="nav-number">5.2.2.</span> <span class="nav-text">using编译指令和using声明之比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="nav-number">5.2.3.</span> <span class="nav-text">名称空间的其他特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">对象和类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">抽象和类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">类的构造函数和析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-number">6.3.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="nav-number">6.4.</span> <span class="nav-text">对象数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">6.5.</span> <span class="nav-text">类作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.6.</span> <span class="nav-text">抽象数据类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB"><span class="nav-number">7.</span> <span class="nav-text">使用类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">7.1.</span> <span class="nav-text">运算符重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">7.2.</span> <span class="nav-text">友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">7.3.</span> <span class="nav-text">类的自动转换和强制类型转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">8.</span> <span class="nav-text">类和动态内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%92%8C%E7%B1%BB"><span class="nav-number">8.1.</span> <span class="nav-text">动态内存和类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.1.</span> <span class="nav-text">特殊成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%8E%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">1．默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%8E%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">2．复制构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%8E%E4%BD%95%E6%97%B6%E8%B0%83%E7%94%A8%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.1.3.</span> <span class="nav-text">3．何时调用复制构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%BC%8E%E9%BB%98%E8%AE%A4%E7%9A%84%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">8.1.1.4.</span> <span class="nav-text">4．默认的复制构造函数的功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">8.1.2.</span> <span class="nav-text">　赋值运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%8E%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%A5%E5%8F%8A%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%AE%83"><span class="nav-number">8.1.2.1.</span> <span class="nav-text">1．赋值运算符的功能以及何时使用它</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%8E%E8%B5%8B%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98%E5%87%BA%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">8.1.2.2.</span> <span class="nav-text">2．赋值的问题出在哪里</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%8E%E8%A7%A3%E5%86%B3%E8%B5%8B%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">8.1.2.3.</span> <span class="nav-text">3．解决赋值的问题</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SuPeng"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">SuPeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SuPeng-Git" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SuPeng-Git" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shuyu0369@163.com" title="E-Mail → mailto:shuyu0369@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SuPeng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
