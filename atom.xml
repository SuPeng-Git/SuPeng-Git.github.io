<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Main</title>
  
  <subtitle>悟已往之不谏，知来者之可追!</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-26T06:03:18.547Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>SuPeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python基础知识</title>
    <link href="http://example.com/2022/03/26/Python/Python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/03/26/Python/Python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-03-26T06:03:38.424Z</published>
    <updated>2022-03-26T06:03:18.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python对象模型"><a href="#Python对象模型" class="headerlink" title="Python对象模型"></a>Python对象模型</h1><div class="table-container"><table><thead><tr><th>对象类型</th><th>类型名称</th><th>简要说明</th></tr></thead><tbody><tr><td>数字</td><td>int float complex</td><td>数字大小没有限制，内置支持复数及其运算</td></tr><tr><td>字符串</td><td>str</td><td></td></tr><tr><td>字节串</td><td>bytes</td><td></td></tr><tr><td>列表</td><td>list</td><td></td></tr><tr><td>字典</td><td>dict</td><td></td></tr><tr><td>元组</td><td>tuple</td><td></td></tr><tr><td>集合</td><td>set frozenset</td><td></td></tr><tr><td>布尔型</td><td>bool</td><td></td></tr><tr><td>空类型</td><td>Node Type</td><td></td></tr><tr><td>异常</td><td>Exception ValueError TypeError</td><td></td></tr><tr><td>文件</td><td></td><td></td></tr><tr><td>其他可迭代对象</td><td></td><td></td></tr><tr><td>编程单元</td><td></td></tr></tbody></table></div><h1 id="Python变量"><a href="#Python变量" class="headerlink" title="Python变量"></a>Python变量</h1><h2 id="Python变量的创建"><a href="#Python变量的创建" class="headerlink" title="Python变量的创建"></a>Python变量的创建</h2><p>在Python中，不需要事先声明变量名及其类型，直接赋值即可创建各种类型的变量，Python解释器会根据赋值或运算来自动推断变量类型。</p><p>Python是一种动态型语言——变量的类型可以随时改变，在显示修改其类型或删除之前，变量一直保持上次的类型。</p><p>大多数情况下，如果变量出现在赋值运算符的活复合赋值运算符的左边表示创建变量或修改变量的值，否则表示引用该变量的值，这一点同样适用于使用下标来访问列表、字典等可变序列以及其他自定义对象中元素的情况。字符串和元组属于不可变序列，这意味着不可通过下标的方式来修改其中的元素值。</p><p>修改变量的值实际修改的是变量的引用，其内存地址会发生变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">22704288</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">22704304</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(y)</span><br><span class="line"><span class="number">22704304</span></span><br></pre></td></tr></table></figure><p><strong>内置函数id()</strong>：返回变量所指值的内存地址。</p><p>Python采用基于值的内存管理方式，如果为不同变量赋值为相同值，这个值在内存中只保存一份，多个变量指向同一个值的内存空间首地址，以减少内存空间的占用，提高内存使用效率。Python启动时，会对[-5,256]的整数进行缓存。对于区间[-5,256]之外的整数，同一个程序中或交互模式下同一个语句中的同值不同名变量会共用同一个内存空间，不同程序或交互模式下不同语句不遵守这个约定。</p><p>Python不会对实数进行缓存，交互模式下不同语句中同值不同名的实数变量不会共用同一个内存空间同一个语句或同一个程序中的同值不同名变量会共用同一个内存空间。</p><h2 id="Python变量的赋值"><a href="#Python变量的赋值" class="headerlink" title="Python变量的赋值"></a>Python变量的赋值</h2><p>Python允许同时为多个变量赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上述示例创建了一个整型对象，值为1，<code>a, b, c</code>是同一对象的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">x, y, z = x+<span class="number">1</span>, x+<span class="number">2</span>, x+<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x, y, z)</span><br><span class="line"><span class="comment"># 输出：2 3 4</span></span><br></pre></td></tr></table></figure><p>连续赋值语句中等式右边其实都是局部变量，先对右边局部变量进行计算然后依次完成赋值运算。</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;变量 1&gt;</span>,<span class="attribute">&lt;变量 2&gt;</span>,<span class="attribute">&lt;变量 3&gt;</span>,...,<span class="attribute">&lt;变量 N&gt;</span> = <span class="attribute">&lt;表达式 &gt;</span><span class="attribute">&lt;表达式 &gt;</span><span class="attribute">&lt;表达式 &gt;</span></span><br></pre></td></tr></table></figure><h2 id="Python变量的回收"><a href="#Python变量的回收" class="headerlink" title="Python变量的回收"></a>Python变量的回收</h2><p>Python具有自动管理内存的功能，会跟踪所有的值，并自动删除不在使用或者引用次数为0的值。如果确定某个值不再使用，可以使用del命令显示删除该变量，值的引用次数减1，当某个变量的引用次数变为0时，将会被Python的垃圾回收机制自动删除并释放内存空间。可以使用标准库函数sys.getrefcount(x)查看对象x的值的引用次数。</p><h2 id="Python的可变与不可变数据类型"><a href="#Python的可变与不可变数据类型" class="headerlink" title="Python的可变与不可变数据类型"></a>Python的可变与不可变数据类型</h2><p><strong>变量作为函数实参传递</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params"> val1 </span>):</span></span><br><span class="line">    val1 = val1 + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">val2 = <span class="number">0</span></span><br><span class="line">fun(val2)</span><br><span class="line"><span class="built_in">print</span>(val2) <span class="comment"># 结果0</span></span><br></pre></td></tr></table></figure><p>实参 <code>val2</code>传递到函数 <code>fun()</code>中，相当于 <code>val1 = val2</code>，这时 <code>val1</code>和 <code>val2</code>指向同一个对象，在函数内部给 <code>val1</code>重新赋值，其实是 <code>val1</code>引用了一个新的对象，并不会修改实参 <code>val2</code>的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funList</span>(<span class="params"> a_list </span>):</span></span><br><span class="line">    a_list[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">  </span><br><span class="line">b_list = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">funList( b_list )</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b_list) <span class="comment"># 输出 [&#x27;X&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>a_list</code>和 <code>b_list</code>是同一对象的引用，<code>b_list</code>在函数中调用对象自己的方法进行修改，这时并没有创建新的对象。</p><p>Python中，函数能不能修改外部变量取决于这个变量的类型是否是可修改类型，<code>string</code>、<code>tuples</code>、<code>int</code>、<code>float</code>是不可变数据类型，<code>list</code>、<code>set</code>、<code>dict</code>是可变数据类型。</p><h2 id="Python变量的命名规范"><a href="#Python变量的命名规范" class="headerlink" title="Python变量的命名规范"></a>Python变量的命名规范</h2><p><strong>Python自定义变量名规范</strong>：</p><ol><li>变量名必须以字母、汉字或下划线开头，但以下划线开头的变量在Python中有特殊含义</li><li>变量名中不能有空格以及标点符号（括号、引号、逗号、斜线、反斜线、冒号、句号、问号等）。</li><li>不能使用关键字作为变量名，可以导入keyword模板后使用print(keyword.kwlist)查看所有PYthon关键字。</li><li>不建议使用相同内置的模块名、类型名或函数名以及已导入的模块名及其成员名作为变量名，这会改变基类型和含义。</li><li>变量名区分英文字母的大小写。</li></ol><h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><p>在Python中，数字类型变量可以表示任意大的数值。</p><p>Python数值类型主要有整数，浮点数和复数。整数类型可以分为下面几种。</p><ol><li>十进制整数</li><li>八进制整数</li><li>二进制整数</li><li>十六进制整数</li></ol><p>Python中的复数与数学中复数的形式完全一致，都是由实部和虚部构成的，使用i或j来表示虚部。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Complex。py</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">3</span> + <span class="number">4j</span></span><br><span class="line">b = <span class="number">5</span> + <span class="number">6j</span></span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(c.real)   <span class="comment"># 查看复数实部</span></span><br><span class="line"><span class="built_in">print</span>(c.imag)   <span class="comment"># 查看复数虚部</span></span><br><span class="line">a.conjugate()   <span class="comment"># 返回共轭复数</span></span><br><span class="line"><span class="built_in">print</span>(a*b)  <span class="comment"># 复数乘法</span></span><br><span class="line"><span class="built_in">print</span>(a/b)  <span class="comment"># 复数除法</span></span><br></pre></td></tr></table></figure><p>Python3.6.x开始支持在数字中间位置使用单个下划线作为分隔符来提高数字的可读性，类似于数学上使用逗号作为千位分隔符，下划线可以位于数字中间任何位置，但不能在开始和结束位置。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>在Python中，字符串属于不可变序列，一般使用单引号、双引号或三引号进行界定，并在单引号、双引号、三单引号、三双引号还可以互相嵌套，用来表示复杂字符串。空字符串表示为’’或””或’’’’’’，即一对不包含任何内容的任意字符串界定符。一对三单引号或三双引号表示的字符串支持换行，支持复排版格式的字符串，也可以在程序中表示较长的注释。</p><p>字符串界定符前面加字母r或R表示原始字符串，其中的特殊字符不进行转义，但字符串的最后不能是单个\符号。原始字符串主要用于正则表达式，也可以用来简化文件路径或URL的输入。</p><div class="table-container"><table><thead><tr><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td>\n</td><td>换行符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\ ‘</td><td>单引号</td></tr><tr><td>\uhhhh</td><td>4位十六进制数对应的字符</td></tr><tr><td>\ “</td><td>双引号</td></tr><tr><td>\ \</td><td>一个 \</td></tr><tr><td>\ooo</td><td>3位八进制数对应的字符</td></tr><tr><td>\xhh</td><td>2位十六进制数对应的字符</td></tr><tr><td>\Uxxxxxxxx</td><td>8位十六进制对应的字符</td></tr></tbody></table></div><h1 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h1><div class="table-container"><table><thead><tr><th>运算符示例</th><th>功能说明</th></tr></thead><tbody><tr><td>x+y</td><td>算术加法，列表、元组、字符串合并</td></tr><tr><td>x-y</td><td>算术减法，集合差集</td></tr><tr><td>x*y</td><td>乘法，序列重复</td></tr><tr><td>x/y</td><td>真除法，结果为实数</td></tr><tr><td>x//y</td><td>求整商，向下取整</td></tr><tr><td>-x</td><td>相反数</td></tr><tr><td>x%y</td><td>余数，字符串格式化</td></tr><tr><td>x**y</td><td>幂运算，y可为实数</td></tr><tr><td>x<y,x<=y,x>y,x&gt;=y</td><td>大小比较，集合包含关系比较</td></tr><tr><td>x==y,x!=y</td><td>相等/不相等比较</td></tr><tr><td>x or y</td><td>逻辑或，短路运算符，最后计算的子表达式的值作为整个表达式的值</td></tr><tr><td>x and y</td><td>逻辑与，短路运算符，最后计算的子表达式的值作为整个表达式的值</td></tr><tr><td>not x</td><td>逻辑非</td></tr><tr><td>x in y, x not in y</td><td>成员测试运算符</td></tr><tr><td>x is y, x is not y</td><td>测试两个对象引用的地址是否相同</td></tr><tr><td>\</td><td>、^、&amp;、&lt;&lt;、&gt;&gt;、~</td><td>位运算符</td></tr><tr><td>&amp;、\</td><td>、^</td><td>集合交集、并集、对称差集</td></tr></tbody></table></div><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表是Python的内置可变序列，是包含若干元素的有序连续内存空间。在形式上，列表的所有元素放在一对方括号”[“和”]”中，相邻元素之间使用逗号隔开。当列表增加或删除元素时，列表对象自动进行内存的扩展或收缩，从而保证元素之间没有缝隙。</p><p>在Python中，同一个列表中元素的类型可以不相同，可以同时包含帧数、实数、字符串等基本类型，也可以是元组、列表、字典、集合以及其它自定义类型的对象。</p><p>列表的常用方法</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>append(x)</td><td>将元素x添加至列表尾部</td></tr><tr><td>extend(iterable)</td><td>将可迭代对象iterable中的所有元素添加到列表尾部</td></tr><tr><td>insert(index, x)</td><td>在列表指定位置index处添加元素x</td></tr><tr><td>remove(x)</td><td>在列表中删除首次出现的指定元素</td></tr><tr><td>pop([index])</td><td>删除并返回列表对象指定位置的元素，默认为最后一个元素</td></tr><tr><td>clear()</td><td>删除列表中所有元素，但保留列表对象</td></tr><tr><td>index(x)</td><td>返回第一个值为x的元素的下标，若不存在值为x的元素，则抛出异常</td></tr><tr><td>count(x)</td><td>返回指定元素x在列表中的出现次数</td></tr><tr><td>reverse(x)</td><td>对列表元素进行原地翻转</td></tr><tr><td>sort(key=None, reverse=False)</td><td>列表元素进行原地排序</td></tr><tr><td>copy()</td><td>返回列表对象的浅复制</td></tr></tbody></table></div><h2 id="列表的创建与删除"><a href="#列表的创建与删除" class="headerlink" title="列表的创建与删除"></a>列表的创建与删除</h2><ol><li>使用赋值运算符“=”直接将一个列表赋值给变量即可创建列表对象。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><ol><li>也可以使用 <code>list()</code>函数将元组、<code>range</code>对象、字符串或其他类型的可迭代对象类型的数据转换为列表。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_list = <span class="built_in">list</span>( (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="string">&#x27;hello word&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>()<span class="comment">#创建空列表</span></span><br></pre></td></tr></table></figure><ol><li>列表推导式可以快速生成符合特定要求的列表</li><li>当不再使用list对象时，使用del命令删除这个list对象</li></ol><h2 id="列表元素的增加"><a href="#列表元素的增加" class="headerlink" title="列表元素的增加"></a>列表元素的增加</h2><p>(1)可以使用 <code>+</code>运算符来实现将元素添加到列表中的功能。严格意义上讲，这并不是真的为列表添加元素，而是创建一个新列表，并将原列表中的元素和新元素依次复制到新列表的内存空间。由于涉及大量元素的复制，该操作速度较慢，在涉及大量元素添加时不建议使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line">aList = aList + [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]，地址：<span class="number">2115227092736</span></span><br><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]，地址：<span class="number">2115227996352</span></span><br></pre></td></tr></table></figure><p>(2)使用列表对象的append()方法，原地修改列表，速度较快，是真正意义上的在列表尾部添加新元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br><span class="line">  </span><br><span class="line">aList.append(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]，地址：<span class="number">2115239179200</span></span><br><span class="line">bList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]，地址：<span class="number">2115239168256</span></span><br><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]，地址：<span class="number">2115227092736</span></span><br><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]，地址：<span class="number">2115227996352</span></span><br><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]，地址：<span class="number">2115224406080</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2115147426160</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2115147426192</span></span><br><span class="line">aList[<span class="number">2</span>]地址:<span class="number">2115147426224</span></span><br><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]，地址：<span class="number">2115224406080</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2115147426160</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2115147426192</span></span><br><span class="line">aList[<span class="number">2</span>]地址:<span class="number">2115147426224</span></span><br><span class="line">aList[<span class="number">3</span>]地址:<span class="number">2115147426256</span></span><br></pre></td></tr></table></figure><p>Python采用的是基于值的自动内存管理方式，当内存对象修改值时，并不是直接修改变量的值，而是使变量指向新的值，这对所有类型都是一样的。</p><p>以列表为例，列表中包含的是元素的引用，而不是直接包含元素值。如果是直接修改列表变量的值，则与Python普通变量的情况是一样的；如果是通过下标来修改列表中的元素的值或通过列表对象自身提供的方法来增加和删除元素时，列表对象在内存中的起始地址是不变的，仅仅是被改变值的元素地址发生变化。</p><p>(3)使用列表对象的 <code>extend()</code>方法可以将另一个可迭代对象的所有元素添加至该列表对象尾部。通过 <code>extend()</code>方法来增加元素也不改变其内存首地址，属于原地操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br><span class="line"></span><br><span class="line">aList.extend( [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]，地址：<span class="number">2115224405440</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2115147426160</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2115147426192</span></span><br><span class="line">aList[<span class="number">2</span>]地址:<span class="number">2115147426224</span></span><br><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]，地址：<span class="number">2115224405440</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2115147426160</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2115147426192</span></span><br><span class="line">aList[<span class="number">2</span>]地址:<span class="number">2115147426224</span></span><br><span class="line">aList[<span class="number">3</span>]地址:<span class="number">2115147426288</span></span><br><span class="line">aList[<span class="number">4</span>]地址:<span class="number">2115147426320</span></span><br><span class="line">aList[<span class="number">5</span>]地址:<span class="number">2115147426352</span></span><br></pre></td></tr></table></figure><p>(4) 使用列表对象的 <code>insert(index, x)</code>方法将元素添加至列表的指定位置，也属于原地操作。<code>insert()</code>方法涉及插入位置之后所有元素的移动，这会影响处理速度，并且导致一些元素的下标发生变化，类似的还有 <code>remove()</code>方法、<code>pop()</code>函数弹出列表非尾部元素和使用del命令删除列表非尾部的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br><span class="line"></span><br><span class="line">aList.insert(<span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br></pre></td></tr></table></figure><p>程序输出;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]，地址：<span class="number">2115259739904</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2115147426160</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2115147426192</span></span><br><span class="line">aList[<span class="number">2</span>]地址:<span class="number">2115147426224</span></span><br><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]，地址：<span class="number">2115259739904</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2115147426160</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2115147426192</span></span><br><span class="line">aList[<span class="number">2</span>]地址:<span class="number">2115147426224</span></span><br><span class="line">aList[<span class="number">3</span>]地址:<span class="number">2115147426256</span></span><br></pre></td></tr></table></figure><p>(5)使用乘法来扩展列表对象，将列表与整数相乘，生成一个新列表，而不是真地扩展原列表，新列表是原列表中元素的重复。需要注意的是，当使用 <code>*</code>运算符将包含列表的列表进行重复并创建新列表时，是创建已有元素的引用。因此，当修改其中一个值时，相应的引用也会被修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = [ [<span class="literal">None</span>]*<span class="number">2</span> ]*<span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:&#123;&#125;,地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>( x, <span class="built_in">id</span>(x) ))</span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;99&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:&#123;&#125;,地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>( x, <span class="built_in">id</span>(x) ))</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x:[[<span class="literal">None</span>, <span class="literal">None</span>], [<span class="literal">None</span>, <span class="literal">None</span>], [<span class="literal">None</span>, <span class="literal">None</span>]],地址：<span class="number">2115259844032</span></span><br><span class="line">x:[[<span class="string">&#x27;99&#x27;</span>, <span class="literal">None</span>], [<span class="string">&#x27;99&#x27;</span>, <span class="literal">None</span>], [<span class="string">&#x27;99&#x27;</span>, <span class="literal">None</span>]],地址：<span class="number">2115259844032</span></span><br></pre></td></tr></table></figure><h2 id="列表元素的删除"><a href="#列表元素的删除" class="headerlink" title="列表元素的删除"></a>列表元素的删除</h2><ol><li>使用del命令删除列表中的指定位置上的元素（del属于原地操作）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> aList[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]，地址：<span class="number">2467643195072</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2467562482032</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2467562482064</span></span><br><span class="line">aList[<span class="number">2</span>]地址:<span class="number">2467562482096</span></span><br><span class="line">aList:[<span class="number">4</span>, <span class="number">5</span>]，地址：<span class="number">2467643195072</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2467562482064</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2467562482096</span></span><br></pre></td></tr></table></figure><ol><li>使用列表的 <code>pop()</code>方法删除并返回指定（默认为最后一个）位置上的元素，如果给定的索引超出列表的范围，则抛出异常。（原地操作）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br><span class="line"></span><br><span class="line">aList.pop()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]，地址：<span class="number">2467639369280</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2467562482032</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2467562482064</span></span><br><span class="line">aList[<span class="number">2</span>]地址:<span class="number">2467562482096</span></span><br><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>]，地址：<span class="number">2467639369280</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2467562482032</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2467562482064</span></span><br></pre></td></tr></table></figure><ol><li>使用列表对象的 <code>remove()</code>方法删除首次出现的指定元素，如果列表中不存在要删除的元素，则抛出异常。（原地操作）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br><span class="line"></span><br><span class="line">aList.remove(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;，地址：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aList[&#123;&#125;]地址:&#123;&#125;&quot;</span>.<span class="built_in">format</span>( i, <span class="built_in">id</span>(aList[i]) ))</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]，地址：<span class="number">2467643192256</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2467562482032</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2467562482064</span></span><br><span class="line">aList[<span class="number">2</span>]地址:<span class="number">2467562482096</span></span><br><span class="line">aList:[<span class="number">3</span>, <span class="number">4</span>]，地址：<span class="number">2467643192256</span></span><br><span class="line">aList[<span class="number">0</span>]地址:<span class="number">2467562482032</span></span><br><span class="line">aList[<span class="number">1</span>]地址:<span class="number">2467562482064</span></span><br></pre></td></tr></table></figure><p>实验：用 <code>remove()</code>方法删除列表中指定元素的所有重复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        x.remove(i)</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>由于列表的的自动内存管理功能，在删除或增加列表元素时，python会自动对列表元素内存进行扩展或收缩并移动列表元素以保证所有元素之间没有空隙。每当插入或删除一个元素之后，该元素位置后面所有元素的索引值都会改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">    <span class="keyword">del</span> x[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>从后向前的顺序删除列表中的重复元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> x[i] == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">del</span> x[i]</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">4</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>列表的切片操作：</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x[::]:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        x.remove(i)</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x[::-<span class="number">1</span>]:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        x.remove(i)</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="列表元素访问与计数"><a href="#列表元素访问与计数" class="headerlink" title="列表元素访问与计数"></a>列表元素访问与计数</h2><ol><li>下标可直接访问列表中的元素。如果指定下标不存在，则抛出异常提示下标越界。</li><li>使用列表对象的 <code>index()</code>方法可以获取指定元素首次出现的下标，语法为 <code>index(value, [start, [stop]])</code>，其中，start和stop用来指定搜索范围，start默认为0，stop默认为列表长度。若列表对象中不存在指定元素，则抛出异常提示列表中不存在该值。</li><li>如果需要知道指定元素在列表中出现的次数，可以使用列表对象的 <code>count()</code>方法进行统计。这方法也可以用于元组、字符串以及 <code>range</code>对象。</li></ol><h2 id="成员资格判断"><a href="#成员资格判断" class="headerlink" title="成员资格判断"></a>成员资格判断</h2><p>如果需要判断列表中是否存在指定的值，可以使用前面介绍的 <code>count()</code>方法；如果存在指定的值，则返回大于0的数；如果返回0.则表示不存在指定的值。或者，使用更加简洁的in关键字来判断一个值是否存在于列表中，返回结果为True或False。</p><p>关键字in和not in也可以用于其他可迭代对象，包括元组、字典、range对象、字符串、集合等，常用在循环语句中对可迭代对象中的元素进行遍历。</p><h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><p>切片是Python中有序序列的重要操作之一，适用于列表、元组、字符串、range对象等类型。切片使用2个冒号分隔的3个数字来完成：<code>[start:stop:step]</code>，第一个数字表示切片开始位置（默认为0），第二个数字表示切片截止（但不包含）位置（默认为列表长度），第三个数字表示切片的步长（默认为1），当步长省略时可以省略最后一个冒号；当步长为负数时，从右往左切。</p><p>可以使用切片来截取列表中的任何部分，得到一个新列表，也可以通过切片来修改和删除列表中的部分元素，甚至可以通过切片操作为列表对象增加元素。</p><p>与使用下标访问列表元素的方法不同，切片操作不会因为下标越界而抛出异常，而是简单地在列表尾部截断或返回一个空列表，代码具有更强的健壮性。</p><p>切片操作作用于元组和字符串时，只能用来读取其中的部分元素，但作用于列表时可以实现很多目的，例如原地修改列表内容，列表元素的增、删、改、查以及元素替换等操作都可以通过切片来实现，并且不影响列表对象在内存中的起始位置。</p><ol><li><p>尾部追加元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(aList[<span class="built_in">len</span>(aList):])</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;id(aList)=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(aList)) )</span><br><span class="line">aList[<span class="built_in">len</span>(aList):] = [<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(aList)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;id(aList)=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(aList)) )</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line"><span class="built_in">id</span>(aList)=<span class="number">1744889706432</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="built_in">id</span>(aList)=<span class="number">1744889706432</span></span><br></pre></td></tr></table></figure></li><li><p>替换列表元素：</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;id(aList)=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(aList)) )</span><br><span class="line">aList[<span class="number">0</span>:<span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(aList)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;id(aList)=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(aList)) )</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span>(aList)=<span class="number">1744889368320</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">id</span>(aList)=<span class="number">1744889368320</span></span><br></pre></td></tr></table></figure><p>示例2：</p><p>切片不连续，要求等号两侧元素数量一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aList = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;aList=&#123;&#125;,id(aList)=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)) )</span><br><span class="line">aList[<span class="number">0</span>::<span class="number">2</span>] = [<span class="number">0</span>] * ( <span class="built_in">len</span>(aList)//<span class="number">2</span> )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;aList=&#123;&#125;,id(aList)=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)) )</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">aList</span>=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],id(aList)=<span class="number">1744889692928</span></span><br><span class="line"><span class="attribute">aList</span>=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>],id(aList)=<span class="number">1744889692928</span></span><br></pre></td></tr></table></figure></li><li><p>删除列表元素：</p><p>示例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;id(aList)=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(aList)) )</span><br><span class="line">aList[<span class="number">0</span>:<span class="number">3</span>] = []</span><br><span class="line"><span class="built_in">print</span>(aList)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;id(aList)=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(aList)) )</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span>(aList)=<span class="number">1744889704704</span></span><br><span class="line">[]</span><br><span class="line"><span class="built_in">id</span>(aList)=<span class="number">1744889704704</span></span><br></pre></td></tr></table></figure><p>示例2：</p><p>del命令与切片操作来删除列表中的部分元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aList = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;aList=&#123;&#125;,id(aList)=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)) )</span><br><span class="line"><span class="keyword">del</span> aList[::<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;aList=&#123;&#125;,id(aList)=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList, <span class="built_in">id</span>(aList)) )</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aList=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],<span class="built_in">id</span>(aList)=<span class="number">1744888648192</span></span><br><span class="line">aList=[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>],<span class="built_in">id</span>(aList)=<span class="number">1744888648192</span></span><br></pre></td></tr></table></figure></li></ol><p>切片返回的是浅复制。所谓浅复制是指生成一个新的列表，并且把源列表中所有元素的引用都复制到新列表中。如果原列表中包含整数、实数、复数等基本类型或元组、字符串这样的不可变类型的数据，一般是没有问题的，包含列表等可变对象时情况比较复杂。</p><pre><code>示例1：</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">bList = aList[:]    <span class="comment">#切片，浅复制</span></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;aList == bList :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList == bList) )    <span class="comment">#切片完成，bList和aList中包含同样的元素引用</span></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;aList is bList :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList <span class="keyword">is</span> bList) )    <span class="comment">#切片得到的bList对象和aList对象不是同一个对象</span></span><br><span class="line">bList[<span class="number">1</span>] = <span class="number">8</span>    <span class="comment">#列表中只包含可哈希对象，修改bList时不影响aList</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bList:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(bList))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList))</span><br><span class="line"></span><br><span class="line">aList = [<span class="number">3</span>, [<span class="number">5</span>], <span class="number">7</span>]</span><br><span class="line">bList = aList[:]    <span class="comment">#切片</span></span><br><span class="line">bList[<span class="number">1</span>].append(<span class="number">6</span>)  <span class="comment">#调用子列表的append()方法，这个方法是原地操作的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bList:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(bList))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList))</span><br></pre></td></tr></table></figure><p>程序输出;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aList == bList :<span class="literal">True</span></span><br><span class="line">aList <span class="keyword">is</span> bList :<span class="literal">False</span></span><br><span class="line">bList:[<span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">aList:[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">bList:[<span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>]</span><br><span class="line">aList:[<span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">aList = [<span class="number">3</span>, [<span class="number">5</span>], <span class="number">7</span>]</span><br><span class="line">bList = copy.deepcopy(aList)<span class="comment">#深复制，递归复制，直到遇到可哈希对象aList和bList完全独立，互不影响</span></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;aList == bList :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList == bList) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;aList is bList :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList <span class="keyword">is</span> bList) )</span><br><span class="line">bList[<span class="number">1</span>].append(<span class="number">6</span>)<span class="comment">#x</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bList:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(bList))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aList:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(aList))</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aList == bList :<span class="literal">True</span></span><br><span class="line">aList <span class="keyword">is</span> bList :<span class="literal">False</span></span><br><span class="line">bList:[<span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>]</span><br><span class="line">aList:[<span class="number">3</span>, [<span class="number">5</span>], <span class="number">7</span>]</span><br></pre></td></tr></table></figure><h2 id="列表排序与逆序"><a href="#列表排序与逆序" class="headerlink" title="列表排序与逆序"></a>列表排序与逆序</h2><p>使用列表对象自身提供的sort()方法可以进行原地排序，没有返回值，或者说返回空值None。</p><p>也可以使用内置函数sorted()对列表进行排序，与列表对象的sort()方法不同，内置函数sorted()返回新列表，并不对原列表进行任何修改。</p><p>Python提供了内置函数reversed()支持对列表元素进行逆序（注意，不是降序）排序，与列表对象的reverse()方法不同，内置函数reversed()不对原列表做任何操作，而是返回一个逆序排序后的迭代对象。</p><h2 id="用于序列操作的常用内置函数"><a href="#用于序列操作的常用内置函数" class="headerlink" title="用于序列操作的常用内置函数"></a>用于序列操作的常用内置函数</h2><ol><li>all()和any()</li></ol><p>all()函数用来测试列表、元组等序列对象以及map()对象、zip对象等类似对象中是否所有元素都等价于True，any()函数用来测试序列或可迭代对象中是否存在等价于True的元素。</p><ol><li>len(列表)</li></ol><p>返回列表中的元素个数，同样适用于元组、字典、集合、字符串、range对象。</p><ol><li>max(列表)、min(列表)</li></ol><p>返回列表中的最大或最小元素，同样适用于元组、字符串、集合、range对象、字典等，要求所有元素之间可以进行大小比较。这两个函数支持使用key参数指定排序规则。</p><ol><li>sum(列表)</li></ol><p>对数值型列表的元素进行求和运算，对非数值型列表运算则需要指定第二个参数，同样适用于元组、集合、range对象、字典以及map对象、filter()对象等。</p><ol><li>zip(*iteraables)</li></ol><p>将多个可迭代对象对应位置的元素组合为元组，并返回包含这些元组对象的zip对象。</p><ol><li>enmuerate(列表)</li></ol><p>枚举列表、字典、元组或字符串中的元素，返回枚举对象，枚举对象中每个元素包含下标和元素值的元组。该函数对字符串、字典同样适用。</p><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式语法形式为<strong>[ exp for variable in iterable if condition ]</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aList = [ x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line">aList = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">aList.append(x*x)</span><br></pre></td></tr></table></figure><ol><li><p>使用列表推导式实现嵌套列表得到平铺。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec = [ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">ivec = [ num <span class="keyword">for</span> elem <span class="keyword">in</span> vec <span class="keyword">for</span> num <span class="keyword">in</span> elem ]</span><br><span class="line"><span class="built_in">print</span>(ivec)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>过滤不符合条件的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aList = [ -<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, -<span class="number">6</span>, <span class="number">3</span>, <span class="number">9.4</span>, -<span class="number">10</span> ]</span><br><span class="line">aList = [ x <span class="keyword">for</span> x <span class="keyword">in</span> aList <span class="keyword">if</span> x&gt;=<span class="number">0</span> ]</span><br><span class="line"><span class="built_in">print</span>(aList)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9.4</span>]</span><br></pre></td></tr></table></figure></li><li><p>在列表推导式中使用多个循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aList = [ (x, y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) ]</span><br><span class="line"><span class="built_in">print</span>(aList)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure></li><li><p>使用列表推导式实现矩阵转置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">matrix = [ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>] ]</span><br><span class="line">tmatrix = [ [row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>) ]</span><br><span class="line"><span class="built_in">print</span>(tmatrix)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure></li><li><p>列表推导式中可以使用函数或复杂表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">v</span>):</span></span><br><span class="line">    <span class="keyword">if</span> v%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        v = v**<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        v = v+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"><span class="built_in">print</span>([f(v) <span class="keyword">for</span> v <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>] <span class="keyword">if</span> v&gt;<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>([v**<span class="number">2</span> <span class="keyword">if</span> v%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> v+<span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>] <span class="keyword">if</span> v&gt;<span class="number">0</span>])  </span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">4</span>, <span class="number">16</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">4</span>, <span class="number">16</span>]</span><br></pre></td></tr></table></figure></li><li><p>列表推导式支持文件对象迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;C:\install.log&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>([line <span class="keyword">for</span> line <span class="keyword">in</span> fp])</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure></li><li><p>使用列表推导式生成100以内的所有素数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">prime_list = [p <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">2</span>, <span class="number">100</span>) <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> [ p%d <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(sqrt(p))+<span class="number">1</span>)] ]</span><br><span class="line"><span class="built_in">print</span>( prime_list )</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>]</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用列表实现向量运算"><a href="#使用列表实现向量运算" class="headerlink" title="使用列表实现向量运算"></a>使用列表实现向量运算</h2><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>元组是轻量级列表，属于不可变序列。</p><h2 id="元组的创建与删除"><a href="#元组的创建与删除" class="headerlink" title="元组的创建与删除"></a>元组的创建与删除</h2><ol><li><p>使用“=”将一个元组赋值给变量，就可以创建一个元组变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a_tuple = ( <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;mailgrim&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;example&#x27;</span> )</span><br><span class="line">x = ()<span class="comment"># 空元组</span></span><br></pre></td></tr></table></figure><p>如果要创建只包含一个元素的元组，需要在唯一元素后面加一个逗号。创建含多个元素的元组没有这个限制。</p></li><li><p>可以使用 <code>tuple()</code>函数将列表、字符串、字典、集合、map对象等其它类型可迭代对象转换为元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">tuple</span>()<span class="comment"># 空元组</span></span><br><span class="line">b_tuple = <span class="built_in">tuple</span>(<span class="string">&#x27;abcdefg&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>只能使用del命令删除整个元组对象，不能只删除元组中的部分元素，因为元组属于不可变序列。</li></ol><h2 id="元组与列表的区别"><a href="#元组与列表的区别" class="headerlink" title="元组与列表的区别"></a>元组与列表的区别</h2><p>列表属于可变序列，可以随意地修改列表中的元素值以及增加和删除列表元素，元组属于 不可变序列，元组一旦定义就不允许通过任何方式更改。</p><p>元组也支持切片操作，但是只能通过切片来访问元组中的元素，不支持使用切片来修改元组中元素的值，也不支持使用切片操作来为元组增加或删除元素。</p><p>元组的访问和处理速度比列表块。</p><p>作为不可变序列，与整数、字符串一样、元组可用作字典的“键”和集合的元素，而列表则永远都不能这样使用。</p><p>虽然元组属于不可变序列，其元素的值是不可改变的，但是如果元组中包含可变序列，情况就略有不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a_tuple = ([<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>)</span><br><span class="line">a_tuple[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a_tuple)</span><br><span class="line">a_tuple[<span class="number">0</span>].append(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(a_tuple)</span><br><span class="line">a_tuple[<span class="number">0</span>] = a_tuple[<span class="number">0</span>] + [<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(a_tuple)</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">([<span class="number">5</span>, <span class="number">2</span>], <span class="number">3</span>)</span><br><span class="line">([<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>], <span class="number">3</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">a:\SOURCE\source_py\source_ipynb\code-<span class="number">1.</span>ipynb Cell <span class="number">33</span><span class="string">&#x27; in &lt;cell line: 6&gt;()</span></span><br><span class="line"><span class="string">      4 a_tuple[0].append(8)</span></span><br><span class="line"><span class="string">      5 print(a_tuple)</span></span><br><span class="line"><span class="string">----&gt; 6 a_tuple[0] = a_tuple[0] + [10]</span></span><br><span class="line"><span class="string">      7 print(a_tuple)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TypeError: &#x27;</span><span class="built_in">tuple</span><span class="string">&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure><p> 如果元组中包含列表、字典、集合或其他可变类型的对象，这样元组不能作为字典“键”或集合的元素。</p><h2 id="序列解包"><a href="#序列解包" class="headerlink" title="序列解包"></a>序列解包</h2><p>在实际开发中，序列解包时非常重要和常用的一个用法，大幅度提高了代码的可读性，并且减少了程序员的代码输入量。例如，可以使用序列解包对多个变量同时进行赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">v_tuple = ( <span class="literal">False</span>, <span class="number">3.5</span>, <span class="string">&#x27;exp&#x27;</span> )</span><br><span class="line">(x, y, z) = v_tuple</span><br></pre></td></tr></table></figure><p>序列解包也可以用于列表和字典，但是对字典使用时，默认是对字典“键”操作，如果需要对“键：值”元素操作，需要使用字典的items()方法说明，如果需要对字典“值”操作，则需要使用字典的values方法明确指定。对字典操作时，不需要对元素的顺序考虑过多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b, c, d = a</span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">b, c, d = s.items()</span><br><span class="line">b, c, d = s</span><br><span class="line">b, c, d = s.values()</span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><p>使用序列解包可以方便地同时遍历多个序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(keys, values):</span><br><span class="line"><span class="built_in">print</span>(k, v)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a <span class="number">1</span></span><br><span class="line">b <span class="number">2</span></span><br><span class="line">c <span class="number">3</span></span><br><span class="line">d <span class="number">4</span></span><br></pre></td></tr></table></figure><p>在调用函数时，在实参前面加上一个或两个星号（*）也可以进行序列解包，从而实现将序列中地元素值依次传递给相同数量的形参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(*[<span class="number">1</span>], *[<span class="number">2</span>], <span class="number">3</span>, *[<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">demo</span>(<span class="params">a, b, c, d</span>):</span></span><br><span class="line">  <span class="built_in">print</span>(a, b, c, d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo(**&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;, **&#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>:<span class="number">4</span>&#125;)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>从形式上看，生成器表达式与列表推导式非常接近，只是生成器表达式使用括号而不是列表推导式所使用的方括号。与列表推导式本质上不同的是，生成器表达式的结果是一个生成器对象。使用生成器对象的元素时，可以根据需要将其传话为列表、集合、或元组，也可以使用内置函数next()、生成器对象的 <code>__next__()</code>方法获取下一个元素，或者直接使用for循环遍历。但是不管用哪种方法访问其元素，当所有元素访问结束以后，如果需要重新访问其中的元素，必须重新创建该生成器对象。也就是说，生成器对象中的每个元素只能使用一次，并且只能从前任往后顺序访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ( (i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x00000118FFF6DDD0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(g)</span><br><span class="line">(<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(g)</span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ( (i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(g)</span><br><span class="line">[<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ( (i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__next__()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ( (i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span> <span class="number">36</span> <span class="number">49</span> <span class="number">64</span> <span class="number">81</span> <span class="number">100</span> <span class="number">121</span></span><br></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典是包含若干”键：值“对的无序可变序列，字典中的每个元素包含两个部分：”键“和”值“。定义字典时，每个元素的”键“和”值“用冒号分隔，相邻元素之间用逗号隔开，所有的元素都放在一对大括号“{”和“}”中。</p><p>字典中的“键”可以是Python中任意不可变数据，例如整数、实数、复数、字符串、元组等，但不能使用列表、集合、字典作为字典的“键”，包含列表、集合、字典的元组也不能作为字典的“键”。另外，字典中的“键”不允许重复，“值”可以重复。</p><h2 id="字典的创建与删除"><a href="#字典的创建与删除" class="headerlink" title="字典的创建与删除"></a>字典的创建与删除</h2><ol><li><p>使用“=”将一个字典赋值给一个变量即可创建一个字典变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_dict =  &#123;<span class="string">&#x27;server&#x27;</span>:<span class="string">&#x27;db.diveinpython3.org&#x27;</span>, <span class="string">&#x27;datebse&#x27;</span>:<span class="string">&#x27;mysql&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用内置函数dict()通过已有数据快速创建字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys, values))</span><br><span class="line">x = <span class="built_in">dict</span>()              <span class="comment"># 空字典</span></span><br><span class="line">x = &#123;&#125;                  <span class="comment"># 空字典</span></span><br></pre></td></tr></table></figure><p>或使用内置函数dict()根据指定的”键：值“来创建字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Dong&#x27;</span>, age=<span class="number">37</span>)</span><br></pre></td></tr></table></figure><p>还可以以给定内容为“键”，创建“值”为空或特定值的字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adict = <span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(adict)</span><br><span class="line">程序输出：</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;age&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><p>当不再使用某个字典时 ，可以使用del命令删除整个字典，也可以使用del命令删除字典中指定的元素。</p><h2 id="字典元素的读取"><a href="#字典元素的读取" class="headerlink" title="字典元素的读取"></a>字典元素的读取</h2><p>可以使用字典的键作为下标来访问字典元素的值，若指定的键不存在则抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aDict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">38</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(aDict[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(aDict[<span class="string">&#x27;tel&#x27;</span>])</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dong</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">KeyError                                  Traceback (most recent call last)</span><br><span class="line">a:\SOURCE\source_py\source_ipynb\code-<span class="number">1.</span>ipynb Cell <span class="number">37</span><span class="string">&#x27; in &lt;cell line: 3&gt;()</span></span><br><span class="line"><span class="string">      1 aDict = &#123;&#x27;</span>name<span class="string">&#x27;: &#x27;</span>Dong<span class="string">&#x27;, &#x27;</span>age<span class="string">&#x27;: 38, &#x27;</span>sex<span class="string">&#x27;: &#x27;</span>male<span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string">      2 print(aDict[&#x27;</span>name<span class="string">&#x27;])</span></span><br><span class="line"><span class="string">----&gt; 3 print(aDict[&#x27;</span>tel<span class="string">&#x27;])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">KeyError: &#x27;</span>tel<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>更加安全的字典元素访问方式时字典对象的get()方法。使用字典对象的get()方法可以获取指定键对应的值，并且可以在指定键不存在的时候返回指定值，如果不指定，则默认返回None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aDict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">38</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(aDict.get(<span class="string">&#x27;address&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(aDict.get(<span class="string">&#x27;address&#x27;</span>, <span class="string">&#x27;SDIBT&#x27;</span>))</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span></span><br><span class="line">SDIBT</span><br></pre></td></tr></table></figure><p>使用字典对象的items()方法可以返回字典的键：值对，使用字典对象的keys()方法可以返回指定的键，使用指定对象的values()方法可以返回指定的“值”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">38</span>, <span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.keys()</span><br><span class="line">dict_keys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.values()</span><br><span class="line">dict_values([<span class="string">&#x27;Dong&#x27;</span>, <span class="number">38</span>, <span class="string">&#x27;male&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.items()</span><br><span class="line">dict_items([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Dong&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">38</span>), (<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> aDict.items():</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(item)</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Dong&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;age&#x27;</span>, <span class="number">38</span>)</span><br><span class="line">(<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, value <span class="keyword">in</span> aDict.items():</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(key,value,sep=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">name:Dong</span><br><span class="line">age:<span class="number">38</span></span><br><span class="line">sex:male</span><br></pre></td></tr></table></figure><h2 id="字典元素的添加和修改"><a href="#字典元素的添加和修改" class="headerlink" title="字典元素的添加和修改"></a>字典元素的添加和修改</h2><p>当以指定键为下标为字典元素赋值时，若该键存在，则表示修改该键的值‘若不存在；则表示添加一个新的键值对，也就是添加一个新的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aDict = &#123; <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;SuPeng&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;men&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">19</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(aDict)</span><br><span class="line">aDict[<span class="string">&#x27;age&#x27;</span>] = <span class="number">20</span></span><br><span class="line">aDict[<span class="string">&#x27;address&#x27;</span>] = <span class="string">&#x27;Chongqing&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(aDict)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;SuPeng&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;men&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">19</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;SuPeng&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;men&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;Chongqing&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>使用字典对象的update()方法将另一个字典的键值对一次性全部添加到当前字典对象，如果两个字典中存在相同的键，则以另一个字典中的值为准对当前字典进行更新。</p><p>当需要删除字典元素时，可以根据具体要求使用del命令删除字典中指定键对应的元素，或者也可以使用字典对象得到clear()方法来删除字典中所有元素，还可以使用字典对象的pop()方法删除并返回指定键的元素，或者使用字典对象的popitem()方法删除并返回字典中的一个元素。</p><h2 id="字典应用案例"><a href="#字典应用案例" class="headerlink" title="字典应用案例"></a>字典应用案例</h2><p>统计字符出现次数：</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choices</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> ascii_letters, digits</span><br><span class="line">z = <span class="string">&#x27;&#x27;</span>.join(choices(ascii_letters,k=<span class="number">1000</span>))</span><br><span class="line">d = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> z:</span><br><span class="line">    d[ch] = d.get(ch, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(d)  </span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;k&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;t&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">27</span>, <span class="string">&#x27;F&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;l&#x27;</span>: <span class="number">17</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;R&#x27;</span>: <span class="number">32</span>, <span class="string">&#x27;p&#x27;</span>: <span class="number">15</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;M&#x27;</span>: <span class="number">19</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">15</span>, <span class="string">&#x27;U&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;w&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;I&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;G&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;Z&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;q&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;h&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;K&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;P&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;A&#x27;</span>: <span class="number">15</span>, <span class="string">&#x27;Q&#x27;</span>: <span class="number">15</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;N&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;Y&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;j&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;S&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;u&#x27;</span>: <span class="number">19</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">26</span>, <span class="string">&#x27;o&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">19</span>, <span class="string">&#x27;O&#x27;</span>: <span class="number">24</span>, <span class="string">&#x27;W&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;v&#x27;</span>: <span class="number">19</span>, <span class="string">&#x27;T&#x27;</span>: <span class="number">17</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">17</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;H&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;J&#x27;</span>: <span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure><p>也可以使用collections模块的defaultdict类来实现该功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choices</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> ascii_letters, digits</span><br><span class="line"></span><br><span class="line">z = <span class="string">&#x27;&#x27;</span>.join(choices(ascii_letters,k=<span class="number">1000</span>))</span><br><span class="line">frequzences = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(frequzences)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> z:</span><br><span class="line">    frequzences[item] += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(frequzences.items())  </span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaultdict(&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;, &#123;&#125;)</span></span><br><span class="line"><span class="class"><span class="title">dict_items</span>(<span class="params">[(<span class="params"><span class="string">&#x27;F&#x27;</span>, <span class="number">21</span></span>), (<span class="params"><span class="string">&#x27;V&#x27;</span>, <span class="number">30</span></span>), (<span class="params"><span class="string">&#x27;P&#x27;</span>, <span class="number">16</span></span>), (<span class="params"><span class="string">&#x27;j&#x27;</span>, <span class="number">16</span></span>), (<span class="params"><span class="string">&#x27;c&#x27;</span>, <span class="number">20</span></span>), (<span class="params"><span class="string">&#x27;I&#x27;</span>, <span class="number">17</span></span>), (<span class="params"><span class="string">&#x27;n&#x27;</span>, <span class="number">21</span></span>), (<span class="params"><span class="string">&#x27;z&#x27;</span>, <span class="number">20</span></span>), (<span class="params"><span class="string">&#x27;H&#x27;</span>, <span class="number">13</span></span>), (<span class="params"><span class="string">&#x27;G&#x27;</span>, <span class="number">17</span></span>), (<span class="params"><span class="string">&#x27;E&#x27;</span>, <span class="number">15</span></span>), (<span class="params"><span class="string">&#x27;R&#x27;</span>, <span class="number">21</span></span>), (<span class="params"><span class="string">&#x27;Q&#x27;</span>, <span class="number">28</span></span>), (<span class="params"><span class="string">&#x27;Y&#x27;</span>, <span class="number">22</span></span>), (<span class="params"><span class="string">&#x27;Z&#x27;</span>, <span class="number">23</span></span>), (<span class="params"><span class="string">&#x27;S&#x27;</span>, <span class="number">20</span></span>), (<span class="params"><span class="string">&#x27;A&#x27;</span>, <span class="number">23</span></span>), (<span class="params"><span class="string">&#x27;r&#x27;</span>, <span class="number">19</span></span>), (<span class="params"><span class="string">&#x27;L&#x27;</span>, <span class="number">26</span></span>), (<span class="params"><span class="string">&#x27;u&#x27;</span>, <span class="number">15</span></span>), (<span class="params"><span class="string">&#x27;p&#x27;</span>, <span class="number">22</span></span>), (<span class="params"><span class="string">&#x27;y&#x27;</span>, <span class="number">20</span></span>), (<span class="params"><span class="string">&#x27;U&#x27;</span>, <span class="number">20</span></span>), (<span class="params"><span class="string">&#x27;w&#x27;</span>, <span class="number">20</span></span>), (<span class="params"><span class="string">&#x27;o&#x27;</span>, <span class="number">21</span></span>), (<span class="params"><span class="string">&#x27;v&#x27;</span>, <span class="number">19</span></span>), (<span class="params"><span class="string">&#x27;h&#x27;</span>, <span class="number">21</span></span>), (<span class="params"><span class="string">&#x27;a&#x27;</span>, <span class="number">26</span></span>), (<span class="params"><span class="string">&#x27;l&#x27;</span>, <span class="number">17</span></span>), (<span class="params"><span class="string">&#x27;J&#x27;</span>, <span class="number">22</span></span>), (<span class="params"><span class="string">&#x27;q&#x27;</span>, <span class="number">26</span></span>), (<span class="params"><span class="string">&#x27;K&#x27;</span>, <span class="number">10</span></span>), (<span class="params"><span class="string">&#x27;f&#x27;</span>, <span class="number">19</span></span>), (<span class="params"><span class="string">&#x27;k&#x27;</span>, <span class="number">21</span></span>), (<span class="params"><span class="string">&#x27;B&#x27;</span>, <span class="number">17</span></span>), (<span class="params"><span class="string">&#x27;b&#x27;</span>, <span class="number">21</span></span>), (<span class="params"><span class="string">&#x27;M&#x27;</span>, <span class="number">16</span></span>), (<span class="params"><span class="string">&#x27;C&#x27;</span>, <span class="number">17</span></span>), (<span class="params"><span class="string">&#x27;D&#x27;</span>, <span class="number">20</span></span>), (<span class="params"><span class="string">&#x27;g&#x27;</span>, <span class="number">17</span></span>), (<span class="params"><span class="string">&#x27;s&#x27;</span>, <span class="number">18</span></span>), (<span class="params"><span class="string">&#x27;N&#x27;</span>, <span class="number">15</span></span>), (<span class="params"><span class="string">&#x27;m&#x27;</span>, <span class="number">15</span></span>), (<span class="params"><span class="string">&#x27;T&#x27;</span>, <span class="number">8</span></span>), (<span class="params"><span class="string">&#x27;t&#x27;</span>, <span class="number">14</span></span>), (<span class="params"><span class="string">&#x27;e&#x27;</span>, <span class="number">17</span></span>), (<span class="params"><span class="string">&#x27;x&#x27;</span>, <span class="number">14</span></span>), (<span class="params"><span class="string">&#x27;O&#x27;</span>, <span class="number">16</span></span>), (<span class="params"><span class="string">&#x27;X&#x27;</span>, <span class="number">22</span></span>), (<span class="params"><span class="string">&#x27;d&#x27;</span>, <span class="number">27</span></span>), (<span class="params"><span class="string">&#x27;i&#x27;</span>, <span class="number">20</span></span>), (<span class="params"><span class="string">&#x27;W&#x27;</span>, <span class="number">19</span></span>)]</span>)</span></span><br></pre></td></tr></table></figure><p>使用collections模块的Counter类可以快速实现这个功能，并且能够满足其他需要，例如查找出现次数最多的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choices</span><br><span class="line"></span><br><span class="line">z = <span class="string">&#x27;&#x27;</span>.join(choices(ascii_letters,k=<span class="number">1000</span>))</span><br><span class="line">frequzences = Counter(z)</span><br><span class="line"><span class="built_in">print</span>(frequzences.items())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;出现次数最多的1个字符和次数:&quot;</span>,frequzences.most_common(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;出现次数最多的3个字符和次数:&quot;</span>,frequzences.most_common(<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict_items([(<span class="string">&#x27;r&#x27;</span>, <span class="number">13</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">21</span>), (<span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>), (<span class="string">&#x27;t&#x27;</span>, <span class="number">23</span>), (<span class="string">&#x27;L&#x27;</span>, <span class="number">30</span>), (<span class="string">&#x27;v&#x27;</span>, <span class="number">29</span>), (<span class="string">&#x27;f&#x27;</span>, <span class="number">21</span>), (<span class="string">&#x27;E&#x27;</span>, <span class="number">17</span>), (<span class="string">&#x27;O&#x27;</span>, <span class="number">22</span>), (<span class="string">&#x27;A&#x27;</span>, <span class="number">23</span>), (<span class="string">&#x27;F&#x27;</span>, <span class="number">22</span>), (<span class="string">&#x27;s&#x27;</span>, <span class="number">29</span>), (<span class="string">&#x27;u&#x27;</span>, <span class="number">19</span>), (<span class="string">&#x27;X&#x27;</span>, <span class="number">22</span>), (<span class="string">&#x27;K&#x27;</span>, <span class="number">26</span>), (<span class="string">&#x27;V&#x27;</span>, <span class="number">28</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">20</span>), (<span class="string">&#x27;g&#x27;</span>, <span class="number">18</span>), (<span class="string">&#x27;x&#x27;</span>, <span class="number">18</span>), (<span class="string">&#x27;z&#x27;</span>, <span class="number">18</span>), (<span class="string">&#x27;i&#x27;</span>, <span class="number">18</span>), (<span class="string">&#x27;o&#x27;</span>, <span class="number">22</span>), (<span class="string">&#x27;j&#x27;</span>, <span class="number">16</span>), (<span class="string">&#x27;w&#x27;</span>, <span class="number">19</span>), (<span class="string">&#x27;J&#x27;</span>, <span class="number">19</span>), (<span class="string">&#x27;Q&#x27;</span>, <span class="number">16</span>), (<span class="string">&#x27;G&#x27;</span>, <span class="number">27</span>), (<span class="string">&#x27;y&#x27;</span>, <span class="number">23</span>), (<span class="string">&#x27;T&#x27;</span>, <span class="number">16</span>), (<span class="string">&#x27;H&#x27;</span>, <span class="number">19</span>), (<span class="string">&#x27;R&#x27;</span>, <span class="number">19</span>), (<span class="string">&#x27;W&#x27;</span>, <span class="number">20</span>), (<span class="string">&#x27;S&#x27;</span>, <span class="number">16</span>), (<span class="string">&#x27;N&#x27;</span>, <span class="number">17</span>), (<span class="string">&#x27;l&#x27;</span>, <span class="number">13</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">16</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="number">18</span>), (<span class="string">&#x27;Z&#x27;</span>, <span class="number">16</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">11</span>), (<span class="string">&#x27;U&#x27;</span>, <span class="number">17</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">22</span>), (<span class="string">&#x27;n&#x27;</span>, <span class="number">19</span>), (<span class="string">&#x27;q&#x27;</span>, <span class="number">21</span>), (<span class="string">&#x27;h&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;p&#x27;</span>, <span class="number">15</span>), (<span class="string">&#x27;Y&#x27;</span>, <span class="number">17</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">25</span>), (<span class="string">&#x27;I&#x27;</span>, <span class="number">17</span>), (<span class="string">&#x27;P&#x27;</span>, <span class="number">17</span>), (<span class="string">&#x27;D&#x27;</span>, <span class="number">11</span>), (<span class="string">&#x27;k&#x27;</span>, <span class="number">16</span>), (<span class="string">&#x27;M&#x27;</span>, <span class="number">13</span>)])</span><br><span class="line">出现次数最多的<span class="number">1</span>个字符和次数: [(<span class="string">&#x27;L&#x27;</span>, <span class="number">30</span>)]</span><br><span class="line">出现次数最多的<span class="number">3</span>个字符和次数: [(<span class="string">&#x27;L&#x27;</span>, <span class="number">30</span>), (<span class="string">&#x27;v&#x27;</span>, <span class="number">29</span>), (<span class="string">&#x27;s&#x27;</span>, <span class="number">29</span>)]</span><br></pre></td></tr></table></figure><h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>类似于列表推导式，Python也可以支持字典推导式快速生成符合特定条件的字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aDict = &#123;i:<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(aDict)</span><br><span class="line">x = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">y = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">aDict = &#123;i:j <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(x, y)&#125;</span><br><span class="line"><span class="built_in">print</span>(aDict)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;2&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;3&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;4&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;A&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;B&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;C&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;D&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合是<strong>无序可变</strong>的容器对象，与字典一样使用一对大括号作为界定符，同一个集合的元素之间不允许重复，集合中每个元素都是唯一的。</p><h2 id="集合的创建于删除"><a href="#集合的创建于删除" class="headerlink" title="集合的创建于删除"></a>集合的创建于删除</h2><p>直接将集合赋值给变量即可创建一个集合对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">3</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>也可以使用set()函数将列表、元组等其他可迭代对象逆换为集合，如果原来地数据中存在重复元素，在转换为集合的时候只保留一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a_set = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">8</span>, <span class="number">14</span>))</span><br><span class="line"><span class="built_in">print</span>(a_set)</span><br><span class="line">b_set = <span class="built_in">set</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(b_set)</span><br><span class="line">x = <span class="built_in">set</span>()       <span class="comment">#空集合</span></span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure><p>可以使用集合对象的add()方法增加元素（元素已存在时自动忽略）。另外，也可以使用集合对象的pop()方法弹出并删除其中的一个元素，或者使用集合对象的remove()方法直接删除指定元素，以及使用集合对象的clear()方法清空集合删除所有元素。当不再使用某个集合时，可以使用del命令删除整个集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a.pop())</span><br><span class="line">a.remove(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.pop(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">a:\SOURCE\source_py\source_ipynb\code-<span class="number">1.</span>ipynb Cell <span class="number">45</span><span class="string">&#x27; in &lt;cell line: 5&gt;()</span></span><br><span class="line"><span class="string">      3 a.remove(3)</span></span><br><span class="line"><span class="string">      4 print(a)</span></span><br><span class="line"><span class="string">----&gt; 5 a.pop(2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TypeError: set.pop() takes no arguments (1 given)</span></span><br></pre></td></tr></table></figure><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><p>Python集合支持交集、并集、差集以及子集测试等运算。</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a_set = <span class="built_in">set</span>([<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>])</span><br><span class="line">b_set = <span class="built_in">set</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(a_set | b_set)    <span class="comment"># 并集</span></span><br><span class="line"><span class="built_in">print</span>(a_set &amp; b_set)    <span class="comment"># 交集</span></span><br><span class="line"><span class="built_in">print</span>(a_set - b_set)    <span class="comment"># 差集</span></span><br><span class="line"><span class="built_in">print</span>(a_set ^ b_set)    <span class="comment"># 对称差集</span></span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line">&#123;<span class="number">8</span>&#125;</span><br><span class="line">&#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">y = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;</span><br><span class="line">z = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(x&lt;y)  <span class="comment"># 比较集的大小</span></span><br><span class="line"><span class="built_in">print</span>(x&lt;z)  <span class="comment"># x 是 z的子集</span></span><br><span class="line"><span class="built_in">print</span>(y&lt;z)  <span class="comment"># y 不是 z的子集</span></span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="集合运用案例"><a href="#集合运用案例" class="headerlink" title="集合运用案例"></a>集合运用案例</h2><p>示例：生成不重复随机数的效率比较，不允许使用rarcdom模块的sample()函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RandomNumbers</span>(<span class="params"> number, start, end </span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;使用列表生成number个介于start~end的不重复随机数&#x27;&#x27;&#x27;</span></span><br><span class="line">    data = []</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        elemnt = random.randint(start, end)</span><br><span class="line">        <span class="keyword">if</span> elemnt <span class="keyword">not</span> <span class="keyword">in</span> data:</span><br><span class="line">            data.append(elemnt)</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> n == number-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RandomNumbers1</span>(<span class="params"> number, start, end </span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;使用列表生成number个介于start~end的不重复随机数&#x27;&#x27;&#x27;</span></span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        elemnt = random.randint(start, end)</span><br><span class="line">        <span class="keyword">if</span> elemnt <span class="keyword">not</span> <span class="keyword">in</span> data:</span><br><span class="line">            data.append(elemnt)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) == number-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RandomNumbers2</span>(<span class="params"> number, start, end </span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;使用列表生成number个介于start~end的不重复随机数&#x27;&#x27;&#x27;</span></span><br><span class="line">    data = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data.add(random.randint(start, end))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data) == number-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    RandomNumbers(<span class="number">50</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;RandomNumbers Time used:&#x27;</span>,time.time()-start)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    RandomNumbers1(<span class="number">50</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;RandomNumbers1 Time used:&#x27;</span>,time.time()-start)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    RandomNumbers2(<span class="number">50</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;RandomNumbers2 Time used:&#x27;</span>,time.time()-start)  </span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RandomNumbers Time used: <span class="number">0.4264869689941406</span></span><br><span class="line">RandomNumbers1 Time used: <span class="number">0.43109798431396484</span></span><br><span class="line">RandomNumbers2 Time used: <span class="number">0.3267791271209717</span></span><br></pre></td></tr></table></figure><h1 id="内置函数storted"><a href="#内置函数storted" class="headerlink" title="内置函数storted()"></a>内置函数storted()</h1><h1 id="复杂数据结构"><a href="#复杂数据结构" class="headerlink" title="复杂数据结构"></a>复杂数据结构</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><h1 id="选择与循环"><a href="#选择与循环" class="headerlink" title="选择与循环"></a>选择与循环</h1><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><p>在Python中，单个常量、变量或者任意合法表达式都可以作为条件表达式。</p><p>在选择和循环结构中，条件表达式的值只要不是False、0（或0.0、0j等）、空值None、空列表、空元组、空集合、空字典、空字符串、空range对象或其他可迭代对象，Python解释器均认为True等价。</p><p>Python中较特殊的运算符：关系运算符（&lt;、&gt;），逻辑运算符（and、or）</p><p>在Python中关系运算符可以连续使用，而在很多语言中是不行的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span>&lt;<span class="number">2</span>&lt;<span class="number">3</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span>&lt;<span class="number">2</span>&gt;<span class="number">3</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span>&lt;<span class="number">3</span>&gt;<span class="number">2</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>逻辑运算符and和or具有短路求值或惰性求值的特点，在设计条件表达式时，如果能够大概预测给条件失败的概率，并将多个条件根据and和or运算的惰性求值特性组织先后顺序，可以大幅度提高程序的运行效率。</p><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式:<span class="comment"># 单分支选择结构</span></span><br><span class="line">    语句块</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 表达式：<span class="comment"># 双分支选择结构</span></span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 表达式：<span class="comment"># 多分支选择结构</span></span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span>:</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line"><span class="keyword">elif</span>:</span><br><span class="line">    语句块<span class="number">3</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句块<span class="number">4</span>   </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>双分支选择结构还有一种更简洁的表达方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span><span class="keyword">if</span>  条件  <span class="keyword">else</span>  表达式<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>while循环：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式:</span><br><span class="line">循环体</span><br></pre></td></tr></table></figure><p>for循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">循环体</span><br></pre></td></tr></table></figure><p>while循环和for循环都可以带else子句，如果循环因为条件表达式不成立而自然结束（不是因为执行了break或continue语句而结束循环），则执行else结构中的语句。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式:</span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">else</span>子句代码块</span><br><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">else</span>子句代码块</span><br></pre></td></tr></table></figure><h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><p>Python中的break和continue语句与C语言中的一般无二。</p><h1 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h1><p>在Python中，字符串使用单引号、双引号、三单引号或三双引号作为界定符，不同的界定符之间可以互相嵌套。字符串属于不可变序列，不能对字符串对象进行元素增加、修改与删除操作。字符串对象提供的replace()、translate()以及其它类似方法并不是对原字符直接修改替换，而是返回一个修改替换后的结果字符串。</p><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><p>字符串格式化用来整数、实数、列表等对象转化为特定格式的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;%[-][+][0][m][.n]格式字符&#x27;</span>% x</span><br></pre></td></tr></table></figure><ul><li>%格式化标志：表示格式开始</li><li>[-]指定左对齐输出</li><li>[+]对正数加正号</li><li>[0]指定空位填0</li><li>[m]指定最小宽度</li><li>[.n]指定精度</li><li>格式字符：指定类型</li><li>%格式运算符</li><li>待转换表达式</li></ul><div class="table-container"><table><thead><tr><th>格式化</th><th>说明</th></tr></thead><tbody><tr><td>%s</td><td>字符串</td></tr><tr><td>%r</td><td>字符串（采用repr()的显示）</td></tr><tr><td>%c</td><td>单个字符</td></tr><tr><td>%d</td><td>十进制整数</td></tr><tr><td>%i</td><td>十进制整数</td></tr><tr><td>%o</td><td>八进制整数</td></tr><tr><td>%x</td><td>十六进制整数</td></tr><tr><td>%e</td><td>指数（基底写为e）</td></tr><tr><td>%E</td><td>指数（基底写为E）</td></tr><tr><td>%f、%F</td><td>浮点数</td></tr><tr><td>%g</td><td>指数（e）或浮点数（根据显示长度）</td></tr><tr><td>%G</td><td>指数（E）或浮点数（根据显示长度）</td></tr><tr><td>%%</td><td>字符“%”</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1235</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%o&#x27;</span>%x</span><br><span class="line"><span class="string">&#x27;2323&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%x&#x27;</span>%x</span><br><span class="line"><span class="string">&#x27;4d3&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%e&#x27;</span>%x</span><br><span class="line"><span class="string">&#x27;1.235000e+03&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%s&#x27;</span>%<span class="number">65</span><span class="comment"># 类似str()</span></span><br><span class="line"><span class="string">&#x27;65&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%d %c&#x27;</span> % (<span class="number">65</span>, <span class="number">65</span>)<span class="comment"># 如果格式化的对象多余一个，要放在元组中</span></span><br><span class="line"><span class="string">&#x27;65 A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%d&#x27;</span> % <span class="string">&#x27;555&#x27;</span><span class="comment"># 试图将字符串转换为整数进行输出，抛出异常</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: %d <span class="built_in">format</span>: a number <span class="keyword">is</span> required, <span class="keyword">not</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p><strong>format()方法格式化</strong></p><p>基本使用格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;模板字符串&gt;</span>.format(<span class="attribute">&lt;逗号分隔的参数&gt;</span>)</span><br></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式由元字符及其不同组合来构成，通过巧妙地构造正则表达式可以匹配任意字符串，并完成复杂地字符串处理任务。</p><div class="table-container"><table><thead><tr><th>元字符</th><th>功能说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意单个字符，单行模式下也可以匹配换行符</td></tr><tr><td>*</td><td>匹配位于 * 之前的字符或子模式的0次或多次重复</td></tr><tr><td>+</td><td>匹配位于 + 之前的字符或子模式的1次或多次重复</td></tr><tr><td>-</td><td>用在[ ]内表示范围</td></tr><tr><td>\</td><td></td><td>匹配位于 \</td><td>之前或之后的字符，表示二选一</td></tr><tr><td>^</td><td>匹配行首，匹配以^后面的字符开头的字符串</td></tr><tr><td>$</td><td>匹配行尾，匹配以$之前的字符结束的字符串</td></tr><tr><td>?</td><td>匹配位于？之前字符或子模式的0次或1次出现。</td></tr><tr><td>\</td><td>表示位于\之后的转义字符</td></tr><tr><td>\num</td><td>此处的num是一个表示子模式序号的正整数。</td></tr><tr><td>\f</td><td>匹配换页符</td></tr><tr><td>\n</td><td>匹配换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\b</td><td>匹配单词头或单词尾</td></tr><tr><td>\B</td><td>与<code>\b</code>含义相反</td></tr><tr><td>\d</td><td>匹配任何数字，相当于<code>[0-9]</code></td></tr><tr><td>\D</td><td>与<code>\d</code>含义相反，等效于<code>[^0-9]</code></td></tr><tr><td>\s</td><td>匹配任何空白字符</td></tr><tr><td>\S</td><td>与’\s’含义相反</td></tr><tr><td>\w</td><td>匹配任何字母、数字以及下划线，相当于[a-zA-Z0-9_]</td></tr><tr><td>\W</td><td>与<code>\w</code>含义相反，与[ ^ a-zA-Z0-9_]等效</td></tr><tr><td>( )</td><td>将位于()的内容作为一个整体对待，表示子模式</td></tr><tr><td>{m, n}</td><td>按{}中次数进行匹配，至少m次，至多n次</td></tr><tr><td>[]</td><td>匹配位于[]中的任意一个字符</td></tr><tr><td><sup><a href="#fn_xyz" id="reffn_xyz">xyz</a></sup></td><td>反向字符集，匹配除x,y,z之外的任何字符</td></tr><tr><td>[a-z]</td><td>字符范围，匹配指定范围内的任何字符</td></tr><tr><td><sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup></td><td>反向范围字符，匹配除小写英文字母之外的任何字符</td></tr><tr><td></td></tr></tbody></table></div><h2 id="re模块主要函数"><a href="#re模块主要函数" class="headerlink" title="re模块主要函数"></a>re模块主要函数</h2><div class="table-container"><table><thead><tr><th>函数</th><th>功能说明</th></tr></thead><tbody><tr><td>compile(pattern[, flags])</td><td>创建正则表达式</td></tr><tr><td>search(pattern, string[, flags])</td><td>在整个字符串中寻找模式，返回Match对象或None</td></tr><tr><td>match(pattern, string[, flags])</td><td>从字符串的开始处匹配模式，返回Match对象或None</td></tr><tr><td>findall(pattern, string[, flags])</td><td>返回字符串中模式的所有匹配项组成的列表</td></tr><tr><td>split(pattern, string[, maxsplit=0])</td><td>根据模式匹配项</td></tr><tr><td>sub(pattern, repl, string[, count=0])</td><td>将字符串中所有pattern的匹配项用repl替换</td></tr><tr><td>escape(string)</td><td>将字符串中所有特殊正则表达式进行转义</td></tr></tbody></table></div><p>其中，函数参数flags的值可以是re.I（忽略大小写），re.L，re.M（多行匹配模式），re.S（使元字符’.’匹配字符，包括换行符），re.U（匹配Unicode字符），re.X（忽略模式中的空格，并可以使用#注释）的不同组合（使用”|”进行组合）。</p><h2 id="直接使用re模块函数"><a href="#直接使用re模块函数" class="headerlink" title="直接使用re模块函数"></a>直接使用re模块函数</h2><p>可以直接使用re模块函数来实现正则表达式操作</p><h2 id="使用正则表达式对象"><a href="#使用正则表达式对象" class="headerlink" title="使用正则表达式对象"></a>使用正则表达式对象</h2><p>首先使用re模块的compile()函数将正则表达式编译生成正则表达式对象，然后再使用正则表达式对象提供的方法进行字符串处理，可以提高字符串处理速度，适合多次使用一个表达式的场景。</p><p>正则表达式对象的match(string[, pos[, endpos]])方法在字符串开头或指定位置进行搜索，模式必须出现在字符串开头或指定位置；search(string[, pos[, endpos]])方法在整个字符串或指定范围进行搜索；findall(string[, pos[, endpos]])方法在字符串中查找所有符合正则表达式的字符串并以列表形式返回。</p><p> 示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">example = <span class="string">&#x27;ShanDong Institute of Business and Technology&#x27;</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\bB\w+\b&#x27;</span>)           <span class="comment"># 以B开头的单词</span></span><br><span class="line"><span class="built_in">print</span>( pattern.findall(example) )</span><br><span class="line"></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+g\b&#x27;</span>)             <span class="comment"># 以g结尾的单词</span></span><br><span class="line"><span class="built_in">print</span>( pattern.findall(example) )</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;Business&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;ShanDong&#x27;</span>]</span><br></pre></td></tr></table></figure><p>​      </p><h2 id="子模式与Match对象"><a href="#子模式与Match对象" class="headerlink" title="子模式与Match对象"></a>子模式与Match对象</h2><p>使用括号表示一个子模式，括号内的内容作为一个整体使用，例如”(red)+”可以匹配redred、redredred等多个重复red的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">telNumber = <span class="string">&#x27;&#x27;&#x27;Suppose my Phone N0. is 0535-1234567,</span></span><br><span class="line"><span class="string">yours is 010-12345678, his is 025-87654321.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(\d&#123;3,4&#125;)-(\d&#123;7,8&#125;)&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>( pattern.findall(telNumber) )</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">&#x27;0535&#x27;</span>, <span class="string">&#x27;1234567&#x27;</span>), (<span class="string">&#x27;010&#x27;</span>, <span class="string">&#x27;12345678&#x27;</span>), (<span class="string">&#x27;025&#x27;</span>, <span class="string">&#x27;87654321&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>正则表达式对象的match()方法和search()方法以及re模块的同名函数匹配成功后都会返回Match对象。Match对象的主要发有group()（返回匹配的一个或多个子模式内容），groups()（返回一个包su偶有子模式内容的元组）、groupdict()（返回包含匹配的所有命名子模式内容的字典）、start()（返回指定子模式内容的起始位置），end()（返回指定子模式内容结束位置的下一个位置）、span()（返回一个包含指定子模式内容起始位置和结束位置的下一个位置的元组）等。下面的代码使用re模块的search()方法返回的Match对象来删除字符串中指定内容，可以自行尝试使用re.sub()函数改写。</p><p>使用子模式扩展语法可以实现更加复杂的字符串处理，子模式扩展         语法如下：</p><p>​                      </p><div class="table-container"><table><thead><tr><th>语法</th><th>功能说明</th></tr></thead><tbody><tr><td>(?p<groupname>)</td><td>为子模式命名</td></tr><tr><td>(?iLmsux)</td><td>设置匹配标志，可以是几个字母的组合，每个字母含义与编译标志相同</td></tr><tr><td>(?:···)</td><td>匹配但不记录该匹配的子表达式</td></tr><tr><td>(?p=groupname)</td><td>表示在此之前的命名为groupname的子模式</td></tr><tr><td>(?#···)</td><td>表示注释</td></tr><tr><td>(?=···)</td><td>用于正则表达式之后，表示如果“=”后的内容在字符串中出现则匹配，但不返回“=”之后的内容</td></tr><tr><td>(?!···)</td><td>用于正则表达式之后，表示如果“!”后的内容在字符串中不出现则匹配，但不返回“!”之后的内容</td></tr><tr><td>(?&lt;=···)</td><td>用于正则表达式之前，与(?=···)含义相同</td></tr><tr><td>(?&lt;!···)</td><td>用于正则表达式之前，与(?!···)含义相同</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">Python基础语法，《Python程序设计》（第三版）读书笔记 ，待完善</summary>
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Python" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>程序设计入门</title>
    <link href="http://example.com/2022/01/19/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/19/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-19T14:57:51.743Z</published>
    <updated>2022-01-19T15:13:28.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.8f\n&quot;</span>, <span class="number">1</span>+<span class="number">2</span>*<span class="built_in">sqrt</span>(<span class="number">3</span>)/(<span class="number">5</span><span class="number">-0.1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>整数值用%d输出，实数值用%f输出</li><li>整数/整数 = 整数， 浮点数/浮点数 =  浮点数</li><li>C语言类型的自动转换</li><li>C语言类型的强制转换</li></ul></blockquote><h1 id="变量及其输入"><a href="#变量及其输入" class="headerlink" title="变量及其输入"></a>变量及其输入</h1><p><strong>例题1-1　圆柱体的面积</strong></p><p>输入底面半径r和高h，输出圆柱体的面积，保留3位小数，格式见样例。<br>样例输入：<br>3.5<br>9<br>样例输出：<br>Area = 247.889</p><p>【分析】<br>圆柱体表面积 = 底面积*2+侧面积<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> r, h, s1, s2, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;r, &amp;h);</span><br><span class="line">    s1 = pi*r*r;</span><br><span class="line">    s2 = <span class="number">2</span>*pi*r*h;</span><br><span class="line">    s = s1*<span class="number">2.0</span> + s2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Area = %.3f\n&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>scanf中的占位符和变量的数据类型一一对应，且每个变量前需要加“&amp;”符号（取址符）。</li><li>在算法比赛中，输入前不要打印提示信息。输出完毕后应立即终止程序，不要等待用户按键，因为输入输出过程都是自动的，没有人工干预。</li><li>在算法比赛中不要使用头文件conio.h,包括getch(),clrscr()等函数。</li><li>在算法竞赛中，每行输出均应以回车符结束，包括最后一行。除特别说明，每行的行首不应有空格，但行末通常可以有多余空格。另外，输出的每两个数或者字符串应以单个空格隔开。</li><li>尽量用const关键字声明常数。</li><li>赋值是个动作，先计算右边的值，再赋值给左边的变量，覆盖它原来的值。=、+=、-=、*=、%=等赋值运算符都是右结合。</li><li>printf的格式字符串中可以包含其他可打印符号，打印时原样输出。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">《算法竞赛入门经典》读书笔记，待完善</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="入门" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
    <category term="《算法竞赛入门经典》" scheme="http://example.com/tags/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++基础知识</title>
    <link href="http://example.com/2022/01/17/C++/C++%E7%B2%BE%E7%AE%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/01/17/C++/C++%E7%B2%BE%E7%AE%80%E8%AF%AD%E6%B3%95/</id>
    <published>2022-01-16T16:05:55.387Z</published>
    <updated>2022-02-25T14:01:20.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用变量：-amp"><a href="#引用变量：-amp" class="headerlink" title="引用变量：&amp;"></a>引用变量：&amp;</h1><p><strong>创建引用声明：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType &amp; name = variate;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：必须在声明引用变量时进行初始化。</strong></p></blockquote><p><strong>将引用用作函数参数——按引用传递</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值函数名(ElementType &amp; name,ElementType &amp; name)&#123;&#125;;</span><br></pre></td></tr></table></figure><p><strong>临时变量 、引用参数和const</strong></p><blockquote><p>如果引用参数是const，则编译器将在下面两种情况下生成<strong>临时变量</strong>：</p><ol><li>实参的类型正确，但不是左值</li><li>实参的类型不正确，但可以转换为正确的类型</li></ol><p>注意：如果函数调用的参数不是左值或与之对应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，<br>将函数调用的参数的值传递给匿名变量，并让参数来引用该变量。</p><p><strong>尽可能使用const</strong></p><ol><li>使用const可以避免无意中修改数据的变长错误；</li><li>使用const使函数能够处理const和非const实参，否则将只能接受非const数据；</li><li>使用const引用使函数能够正确生成并使用临时变量。</li></ol></blockquote><p><strong>返回引用</strong></p><blockquote><p>返回引用的函数实际上是被引用的变量的别名。<br>返回引用应避免返回函数终止时不再存在的内存单元引用。<br>为避免这种问题，可以考虑返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用也指向这些数据。<br>另一种方法是用new类分配新的存储空间。但在不再需要new分配内存时，用使用delete来释放它们。<br>返回const引用—即不可修改的左值</p></blockquote><p><strong>何时使用引用参数</strong></p><blockquote><p>使用引用参数的主要原因：<br>程序员能够修改调用的函数中的数据对象<br>通过传递引用而不是整个数据对象，可以提高程序的运行速度。</p></blockquote><p>对于使用传递的值而不做修改的函数：</p><ul><li>如果数据对象很小，若内置数据类型或小型结构，则按值传递</li><li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。</li><li>如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省赋值结构所需的时间和空间。</li><li>如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。</li></ul><p>对于修改调用函数中数据的函数:</p><ul><li>如果数据对象是内置数据类型，则使用指针。</li><li>如果数据对象是数组，则只能使用指针。</li><li>如果数据对象是结构，则使用引用或指针。</li><li>如果数据对象是类对象，则使用引用。</li></ul><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p><strong>默认参数</strong>：指的是当函数调用中省略了实参时自动使用的一个值。</p><p><strong>默认参数的设置</strong></p><p>将默认值赋给原型中的参数。只有原型包含默认值的信息,函数定义无需修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[返回值类型] [函数名](ElementType _val = [默认值]);</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>在函数调用中，实参按从左往右的顺序依次被赋给形参，而不能跳过任何参数。</li><li>如果某个位置有了默认参数，那么从这个位置往后都要有默认值。即只能在参数列表中从右到左提供默认参数。因此，如果为某个参数提供了默认值，则必须为该参数右边所有的参数提供默认值。</li></ul></blockquote><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>函数多态是C++在C语言基础上新增的功能。默认参数允许使用不同数目的参数调用同一个函数，而函数多态（函数重载）允许使用多个同名的函数。</p><p>术语“多态”指的是有多种形式，因此函数多态允许函数可以有多种形式。术语“函数重载”指的是可以有多个同名的函数，第名称进行了重载。</p><p>函数重载的关键是函数的参数列表——也称为函数的特征标。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。</p><p>注意：类型引用和类型本身视为同一特征标。</p><p><strong>何时使用函数重载</strong>：仅当函数基本上执行相同的任务，但使用不同形式的数据时使用函数重载。</p><blockquote><p>拓展：名称修饰</p><p>C++编译器执行一些神奇的操作——名称修饰或名名称矫正，它根据函数原型中指定的形参类型对每个函数进行加密。</p></blockquote><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p><strong>函数模板</strong>：函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。</p><p><strong>建立函数模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;</span><br><span class="line">[返回值类型] [函数名](AnyType a, AnyType b)&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行指出，要建立一个函数模板，并将类型命名为AnyType。类型名可以自定义，但要遵守C++命名规范。关键字template和typename是必需的。在标准C++98添加关键字typename之前，C++使用关键字class来创建模板。</p><p><strong>提示</strong>：如果需要多个将同一种算法用于不同类型的函数，则使用模板。如果不考虑向后兼容的问题，并愿意键入较长的单词，则声明类型参数时，应使用typename而不使用class。</p><p><strong>函数模板重载</strong></p><p>和常规函数重载相同，被重载的模板的函数特征标必须不同。</p><p><strong>模板的局限性</strong></p><p>编写的模板函数很可能无法处理某些类型。</p><p><strong>显示具体化</strong></p><p>当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。</p><ul><li>第三代具体化（ISO/ANSI C++标准）</li></ul><p>对于给定的函数名，可以有非模板函数、模板函数和显示具体化模板函数以及它们的重载版本。<br>显示具体化的原型和定义应以template&lt;&gt;打头，并通过名称来指出类型。<br>具体化优先于常规模板，而非模板函数优先于具体化和常规化模板。</p><p><strong>实例化和具体化</strong></p><ul><li>模板实例：编译器使用模板为特定类型生成函数定义时，得到的是模板实例。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">0.2</span>;</span><br><span class="line">cout &lt;&lt; Add&lt;<span class="keyword">double</span>&gt;(x, x);  <span class="comment">//显示示例</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>(m , m); <span class="comment">//隐式实例化</span></span><br></pre></td></tr></table></figure><ul><li>具体化（specialization）：隐式实例化、显示实例化和显示实例化统称具体化。它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。</li></ul><blockquote><p>引用显示实例化后，必须使用新的语法——在声明中使用前缀template和template&lt;&gt;，以区分显示实例化和具体实例化。</p><p>警告：试图在同一文件（或转换单元）中使用同一种类型的显示实例化和显式具体化将出错。</p></blockquote><p><strong>编译器选择使用哪个函数版本</strong></p><ul><li>重载解析：C++通过已确立的策略来决定为函数调用使用哪一个函数定义的过程称为重载解析。</li></ul><blockquote><ol><li>第一步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。</li><li>第二部：使用候选函数列表创建可行函数。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包含实参类型与相应的形参类型完全的情况。</li><li>第三步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。</li></ol></blockquote><ol><li>完全匹配和最佳匹配</li></ol><div class="table-container"><table><thead><tr><th>从实参</th><th>到形参</th></tr></thead><tbody><tr><td>Type</td><td>Type &amp;</td></tr><tr><td>Type &amp;</td><td>Type</td></tr><tr><td>Type []</td><td>*Type</td></tr><tr><td>Type (argument)</td><td>Type * (argument)</td></tr><tr><td>Type</td><td>const Type</td></tr><tr><td>Type</td><td>volatile Type</td></tr><tr><td>Type*</td><td>const Type</td></tr><tr><td>Type*</td><td>volatile Type*</td></tr></tbody></table></div><p>如果有多个匹配的原型，则编译器将无法完成重载解析过程；如果没有最佳的可行函数，则编译器将生成一条错误消息，该消息可能会使用诸如“ambiguous（二义性）”这样的词语。然而，有时候，即使两个函数都完全匹配，仍可完成重载解析。首先，指向非const数据的指针和引用优先与非const指针和引用参数匹配。const和非const之间的区别只适用于指针和引用指向的数据。</p><p>一个完全匹配优于另一个的另一种情况是，其中一个时非模板函数，而另一个不是。在这种情况下，非模板函数优先于模板函数（包括显式具体化）。具体化优先于常规模板，而非模板函数优先于具体化和常规化模板。</p><p>如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先。例如，这意味着显式具体化将优于使用模板隐式生成的具体化。</p><p>术语“最具体（most specialized）”并不一定意味着显式具体化，而是指编译器推断使用哪种类型时执行的转换最少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="function"><span class="keyword">void</span> <span class="title">recycle</span> <span class="params">(Type t)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="function"><span class="keyword">void</span> <span class="title">recycle</span> <span class="params">(Type * t)</span></span>; <span class="comment">// #2</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blot</span> &#123;</span><span class="keyword">int</span> a; <span class="keyword">char</span> b[<span class="number">10</span>];&#125;;</span><br><span class="line">blot ink = &#123;<span class="number">25</span>, <span class="string">&quot;spots&quot;</span>&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">recycle</span>(&amp;ink); <span class="comment">// address of a structure</span></span><br></pre></td></tr></table></figure><blockquote><p>recycle(&amp;ink)调用与#1模板匹配，匹配时将Type解释为blot <em>。recycle(&amp;ink)函数调用也与#2模板匹配，这次Type被解释为blot。因此将两个隐式实例——recycle&lt;blot </em>&gt;(blot <em>)和recycle <blot>(blot </em>)发送到可行函数池中。<br>在这两个模板函数中，recycle<blot *>(blot *)被认为是更具体的，因为在生成过程中，它需要进行的转换更少。也就是说，#2模板已经显式指出，函数参数是指向Type的指针，因此可以直接用blot标识Type；而#1模板将Type作为函数参数，因此Type必须被解释为指向blot的指针。也就是说，在#2模板中，Type已经被具体化为指针，因此说它“更具体”。</p></blockquote><p>用于找出最具体的模板的规则被称为函数模板的部分排序规则（partial ordering rules）。和显式实例一样，这也是C++98新增的特性。</p><ol><li>创建自定义选择</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[函数名]&lt;&gt;([实参]);</span><br><span class="line"><span class="comment">// &lt;&gt;指出，编译器应选择模板函数，而不是非模板函数；</span></span><br><span class="line">[函数名]&lt;类型&gt;([实参]);</span><br><span class="line"><span class="comment">// &lt;类型&gt;要求进行显示实例化</span></span><br></pre></td></tr></table></figure><p><strong>关键字decltype（C++11）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression) var;<span class="comment">// make var the same type as x;</span></span><br></pre></td></tr></table></figure><p>给decltype提供的参数可以是表达式、标识符。</p><ul><li>如果expression是一个没有用括号括起的标识符，则var的类型与该标识符的类型相同，包括const等限定符。</li><li>如果expression是一个函数调用，则var的类型与函数的返回类型相同。</li><li>如果expression是一个左值，则var为指向其类型的引用。expression是用括号括起的标识符。</li><li>如果前面的条件都不满足，则var的类型与expression的类型相同</li></ul><blockquote><p>注意：<br>给decltype提供的参数是表达式时，并不会调用函数。编译器通过查看函数的原型来获悉返回类型，而无需调用函数。<br>括号并不会改变表达式的值和左值性。</p></blockquote><p><strong>另一种函数声明语法——C++11后置返回类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">gt</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将返回类型移到了参数声明后面。-&gt;double被称为后置返回类型（trailing return type）。其中auto是一个占位符，表示后置返回类型提供的类型，这是C++11给auto新增的一种角色。这种语法也可用于函数定义.</p><h1 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h1><h2 id="传统的C-名称空间"><a href="#传统的C-名称空间" class="headerlink" title="传统的C++名称空间"></a>传统的C++名称空间</h2><p><strong>声明区域（declaration）</strong>：声明区域是可以在其中进行声明的区域。</p><p><strong>潜在作用域（potential scope）</strong>：变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。</p><p><strong>作用域（scope）</strong>：变量对程序而言可见的范围被称为作用域。</p><blockquote><p>变量并非在其潜在作用域内的任何位置都是可见的。例如，它可能被另一个在嵌套声明区域中声明的同名变量隐藏。例如，在函数中声明的局部变量（对于这种变量，声明区域为整个函数）将隐藏在同一个文件中声明的全局变量（对于这种变量，声明区域为整个文件）。</p></blockquote><p>C++关于全局变量和局部变量的规则定义了一种名称空间层次。每个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的名称。在一个函数中声明的局部变量不会与在另一个函数中声明的局部变量发生冲突。</p><h2 id="新的空间特性"><a href="#新的空间特性" class="headerlink" title="新的空间特性"></a>新的空间特性</h2><p>C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。</p><p>名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。</p><p><strong>全局空间</strong>：除了用户定义的名称空间外，还存在另一个名称空间——全局名称空间（global namespace）。它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中。</p><p>任何名称空间中的名称都不会与其他名称空间中的名称发生冲突。</p><p>未被装饰的名称（如pail）称为未限定的名称（unqualified name）；包含名称空间的名称（如Jack::pail）称为限定的名称（qualified name）。</p><h3 id="using声明和using编译"><a href="#using声明和using编译" class="headerlink" title="using声明和using编译"></a>using声明和using编译</h3><p>using声明使特定的标识符可用，using编译指令使整个名称空间可用。</p><p><strong>using声明</strong>：using声明由被限定的名称和它前面的关键字using组成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Jill::fetch; <span class="comment">// a using declaration</span></span><br></pre></td></tr></table></figure><p>using声明将特定的名称添加到它(using声明)所属的声明区域中。</p><p><strong>using编译</strong>：using声明使一个名称可用，而using编译指令使所有的名称都可用。using编译指令由名称空间名和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Jack; <span class="comment">// make all the names in Jack available</span></span><br></pre></td></tr></table></figure><p>使用using编译和using声明增加了名称冲突的可能，存在二义性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jack::pal = <span class="number">3</span>;</span><br><span class="line">jill::pal =<span class="number">10</span>;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">using</span> jack::pal;</span><br><span class="line"><span class="keyword">using</span> jill::pal;</span><br><span class="line">pal = <span class="number">4</span>;       <span class="comment">// which one? now have a conflict</span></span><br></pre></td></tr></table></figure><h3 id="using编译指令和using声明之比较"><a href="#using编译指令和using声明之比较" class="headerlink" title="using编译指令和using声明之比较"></a>using编译指令和using声明之比较</h3><p>如果某个名称已经在函数中声明了，则不能用using声明导入相同的名称。如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。</p><blockquote><p>注意：<br>假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，则这两个名称会发生冲突，从而出错。如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。</p></blockquote><h3 id="名称空间的其他特性"><a href="#名称空间的其他特性" class="headerlink" title="名称空间的其他特性"></a>名称空间的其他特性</h3><p><strong>可嵌套</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> elements</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> fire</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flame;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> water;</span><br><span class="line">&#125;   <span class="comment">//无分号;</span></span><br></pre></td></tr></table></figure><p><strong>*using编译指令的传递性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myth</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Jill::fetch;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> elements;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::cin;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> myth;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> myth;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> elements;</span><br><span class="line"><span class="comment">// 与using namespace myth;等价</span></span><br></pre></td></tr></table></figure><p><strong>名称空间的别名</strong><br>可以给名称空间创建别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MH = myth;</span><br></pre></td></tr></table></figure><p><strong>未命名的名称空间</strong><br>可以通过省略名称空间的名称来创建未命名的名称空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="comment">// unnamed namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ice;</span><br><span class="line">    <span class="keyword">int</span> bandycoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这种名称空间没有名称，因此不能显式地使用using编译指令或using声明来使它在其他位置都可用。具体地说，不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称。这提供了链接性为内部的静态变量的替代品。</p><p><strong>关于名称空间的使用规范</strong></p><blockquote><ul><li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</li><li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</li><li>如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++当前提倡将标准函数库放在名称空间std中，这种做法扩展到了来自C语言中的函数。例如，头文件math.h是与C语言兼容的，没有使用名称空间，但C++头文件cmath应将各种数学库函数放在名称空间std中。实际上，并非所有的编译器都完成了这种过渡。</li><li>仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。</li><li>不要在头文件中使用using编译指令。这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include之后。</li><li>导入名称时，首选使用作用域解析运算符或using声明的方法。</li><li>对于using声明，首选将其作用域设置为局部而不是全局。</li></ul></blockquote><h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><h2 id="抽象和类"><a href="#抽象和类" class="headerlink" title="抽象和类"></a>抽象和类</h2><p><strong>类</strong>：类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。</p><p><strong>接口</strong>：接口是一个共享框架，供两个系统（如在计算机和打印机之间或者用户或计算机程序之间）交互时使用。</p><p>通常，C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码文件中。这里采用这种典型做法。</p><p><strong>访问控制</strong>：关键字private、public和protect描述了对类成员的访问控制。使用类对象的程序都可以直接访问共有部分，但只能通过共有成员函数或友元函数来访问私有对象。</p><p>类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽象组件。将实现细节放在一起并将它们与抽象分开被称为封装。数据隐藏（将数据放在类的私有部分中）是一种封装，将实现的细节隐藏在私有部分中，也是一种封装。封装的另一个例子是，将类函数定义和类声明放在不同的文件中。</p><p><strong>实现类成员函数</strong></p><p>创建类描述的第二部分：为那些由类声明中的原型表示的成员函数提供代码。成员函数定义与常规函数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：</p><ul><li>定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类；</li><li>类方法可以访问类的private组件。</li></ul><p><strong>内联方法</strong></p><p>其定义位于类声明中的函数都将自动成为内联函数；如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。为此，只需在类实现部分中定义函数时使用inline限定符即可。</p><p>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用的、最简便的方法是：将内联定义放在定义类的头文件中（有些开发系统包含智能链接程序，允许将内联定义放在一个独立的实现文件）。</p><p>根据改写规则（rewrite rule），在类声明中定义方法等同于用原型替换方法定义，然后在类声明的后面将定义改写为内联函数。</p><p><strong>类的声明</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    data member declarations</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    member function prototypes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类声明类似结构声明，可以包括数据成员和函数成员。声明有私有部分，在其中声明的成员只能通过成员函数进行访问；声明还具有公有部分，在其中声明的成员可被使用类对象的程序直接访问。通常，数据成员被放在私有部分中，成员函数被放在公有部分中.</p><p>公有部分的内容构成了设计的抽象部分——公有接口。将数据封装到私有部分中可以保护数据的完整性，这被称为数据隐藏。因此，C++通过类使得实现抽象、数据隐藏和封装等OOP特性很容易。</p><p><strong>实现类成员函数</strong></p><p>可以在类声明中提供完整的函数定义，而不是函数原型，但是通常的做法是单独提供函数定义（除非函数很小）。在这种情况下，需要使用作用域解析运算符来指出成员函数属于哪个类。例如，假设Bozo有一个名为Retort()的成员函数，该函数返回char指针，则其函数头如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Bozo::Retort</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员是const整数类型或枚举型，则可以在类声明中初始化。</p></blockquote><h2 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h2><p>构造函数是一种特殊的类成员函数，在创建类对象时被调用。另外，构造函数没有声明类型。</p><p><strong>使用构造函数</strong></p><p>C++提供了两种使用构造函数来初始化对象的方式。第一种方式是显式地调用构造函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock s1 = <span class="built_in">stock</span>(...);</span><br></pre></td></tr></table></figure><p>另一种方式是隐式地调用构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stock <span class="title">s1</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="comment">// 等价于stock s1 = stock(...);</span></span><br></pre></td></tr></table></figure><p>每次创建类对象（甚至使用new动态分配内存）时，C++都使用类构造函数。下面是将构造函数与new一起使用的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock *p_stock = <span class="keyword">new</span> <span class="built_in">stock</span>(...);</span><br></pre></td></tr></table></figure><p><strong>默认构造函数</strong>：默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。如果没有提供任何构造函数，则C++将自动提供默认构造函数。它是默认构造函数的隐式版本，不做任何工作。</p><blockquote><p>同理可得，非默认构造函数是提供了显示初始化值来创建对象的构造函数</p></blockquote><p>当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造函数。如果提供了非默认构造函数（如Stock(const char * co, int n, double pr)），但没有提供默认构造函数，则下面的声明将出错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock stock1; <span class="comment">// not possible with current constructor</span></span><br></pre></td></tr></table></figure><p>如果要创建对象，而不显式地初始化，则必须定义一个不接受任何参数的默认构造函数。定义默认构造函数的方式有两种。一种是给已有构造函数的所有参数提供默认值。另一种方式是通过函数重载来定义另一个构造函数—— 一个没有参数的构造函数。</p><p>由于只能有一个默认构造函数，因此不要同时采用这两种方式。实际上，通常应初始化所有的对象，以确保所有成员一开始就有已知的合理值。因此，用户定义的默认构造函数通常给所有成员提供隐式初始值。</p><blockquote><p>提示：　<br>在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数。<br>隐式地调用默认构造函数时，不要使用圆括号。<br>如果既可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化方式。通常这种方式的效率更高。</p><p>警告：<br>接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Classname object = value;</span><br></pre></td></tr></table></figure><p><strong>析构函数</strong></p><p>用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。对象过期时，程序将自动调用一个特殊的成员函数，该函数的名称令人生畏——析构函数。析构函数完成清理工作，因此实际上很有用。</p><p>和构造函数一样，析构函数的名称也很特殊：在类名前加上~。</p><p>如果程序创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用。如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用。最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。</p><p>由于在类对象过期时析构函数将自动被调用，因此必须有一个析构函数。如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除的代码后，提供默认析构函数的定义。</p><p><strong>C++11列表初始化</strong></p><p>在C++11中，可将列表初始化语法用于类，只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stock hot_tip = &#123;...&#125;;</span><br><span class="line">stock jock &#123;...&#125;;</span><br><span class="line">stock temp &#123;&#125;;</span><br></pre></td></tr></table></figure><p><strong>const成员函数</strong>：一种保证函数不会被修改调用对象的新语法。</p><p>const成员函数是在成员函数的基础上将const关键字放在函数的括号后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[返回值类型] [函数名]() <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// const成员函数定义</span></span><br><span class="line">[返回值类型] [函数名]() <span class="keyword">const</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>一般来说，所有的类方法都将this指针设置为调用它的对象的地址。</p><p>每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象。如果方法需要引用整个调用对象，则可以使用表达式*this。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。</p><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数初始化</span></span><br><span class="line">Classname object[numbers];</span><br><span class="line"><span class="comment">// 构造函数初始化</span></span><br><span class="line">Classname object[numbers] = &#123;</span><br><span class="line">    <span class="built_in">Classname</span>(...),</span><br><span class="line">    <span class="built_in">Classname</span>(...),</span><br><span class="line">    ....</span><br><span class="line">    <span class="built_in">Classname</span>(...),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有默认构造函数。</p><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><blockquote><p>C++类引入了一种新的作用域：类作用域。</p></blockquote><p>在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。也就是说，要调用公有成员函数，必须通过对象。</p><p><strong>作用域为类的常量</strong></p><p>第一种方式是在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>Months = <span class="number">12</span>&#125;; <span class="comment">//由于这里使用枚举只是为了创建符号常量，并不打算创建枚举类型的变量，因此不需要提供枚举名。</span></span><br><span class="line">    <span class="keyword">double</span> costs[Months];</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>注意，用这种方式声明枚举并不会创建类数据成员。也就是说，所有对象中都不包含枚举。另外，Months只是一个符号名称，在作用域为整个类的代码中遇到它时，编译器将用12来替换它。</p><p>C++提供了另一种在类中定义常量的方式——使用关键字static：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;   <span class="comment">//静态类成员</span></span><br><span class="line">    <span class="keyword">double</span> costs[Months];</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>这将创建一个名为Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。因此，只有一个Months常量，被所有Bakery对象共享。</p><p><strong>作用域内枚举（C++11）</strong></p><p>C++11提供了一种新枚举，其枚举量的作用域为类。这种枚举的声明类似于下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">name</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="comment">//  也可使用关键字struct代替class</span></span><br></pre></td></tr></table></figure><p>枚举量的作用域为类后，不同枚举定义中的枚举量就不会发生名称冲突。</p><p>C++11还提高了作用域内枚举的类型安全。在有些情况下，常规枚举将自动转换为整型，如将其赋给int变量或用于比较表达式时，但作用域内枚举不能隐式地转换为整型。但在必要时，可进行显式类型转换。</p><p>默认情况下，C++11作用域内枚举的底层类型为int。另外，还提供了一种语法，可用于做出不同的选择：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// underlying type for pizza is short</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> :</span> <span class="keyword">short</span> pizza &#123;Small, Medium, Large, XLarge&#125;;</span><br></pre></td></tr></table></figure><p>:short将底层类型指定为short。底层类型必须为整型。在C++11中，也可使用这种语法来指定常规枚举的底层类型，但如果没有指定，编译器选择的底层类型将随实现而异。</p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p><strong>栈</strong></p><ul><li>可创建空栈。</li><li>可将数据项添加到栈顶（压入）。</li><li>可从栈顶删除数据项（弹出）。</li><li>可查看栈否填满。</li><li>可查看栈是否为空。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack.h -- class definition for the stack ADT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> Item;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>MAX = <span class="number">10</span>&#125;; <span class="comment">// constant specific to class</span></span><br><span class="line">    Item items[MAX]; <span class="comment">// holds stack items</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">// index for top stack item</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// push() returns false if stack already is full, true otherwise</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Item &amp; item)</span></span>; <span class="comment">// add item to stack</span></span><br><span class="line">    <span class="comment">// pop() returns false if stack already is empty, true otherwise</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(Item &amp; item)</span></span>; <span class="comment">// pop top into item</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack.cpp -- Stack member functions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stack.h&quot;</span></span></span><br><span class="line">Stack::<span class="built_in">Stack</span>() <span class="comment">// create an empty stack</span></span><br><span class="line">&#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::isempty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::isfull</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="keyword">const</span> Item &amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        items[top++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::pop</span><span class="params">(Item &amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        item = items[--top];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h1><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载是一种形式的C++多态。</p><p>要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[classname]<span class="function"><span class="keyword">operator</span> <span class="title">op</span><span class="params">(argument-list)</span></span></span><br></pre></td></tr></table></figure><p>例如，operator +()重载+运算符，operator <em>()重载 </em>运算符。op必须是有效的C++运算符，不能虚构一个新的符号。</p><p><strong>重载限制</strong></p><ol><li>重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。因此，不能将减法运算符（−）重载为计算两个double值的和，而不是它们的差。虽然这种限制将对创造性有所影响，但可以确保程序正常运行。</li><li>使用运算符时不能违反运算符原来的句法规则。例如，不能修改运算符的优先级。因此，如果将加号运算符重载成将两个类相加，则新的运算符与原来的加号具有相同的优先级。</li><li>不能创建新运算符。</li><li>不能重载下面的运算符。</li></ol><blockquote><ul><li>sizeof：sizeof运算符。</li><li>.：成员运算符。</li><li>*：成员指针运算符。</li><li>::：作用域解析运算符。</li><li>?:：条件运算符。</li><li>typeid：一个RTTI运算符。</li><li>const_cast：强制类型转换运算符。</li><li>dynamic_cast：强制类型转换运算符。</li><li>reinterpret_cast：强制类型转换运算符。</li><li>static_cast：强制类型转换运算符。</li></ul></blockquote><p><strong>可重载运算符</strong></p><div class="table-container"><table><thead><tr><th>+</th><th>-</th><th>*</th><th>/</th><th>%</th><th>^</th></tr></thead><tbody><tr><td>&amp;</td><td>\</td><td></td><td>~=</td><td>!</td><td>=</td><td>&lt;</td></tr><tr><td>&gt;</td><td>+=</td><td>-=</td><td>*=</td><td>/=</td><td>%=</td></tr><tr><td>^=</td><td>&amp;=</td><td>\</td><td>=</td><td>&lt;&lt;</td><td>&gt;&gt;</td><td>&gt;&gt;=</td></tr><tr><td>&lt;&lt;=</td><td>==</td><td>!=</td><td>&lt;=</td><td>&gt;=</td><td>&amp;&amp;</td></tr><tr><td>\</td><td>\</td><td></td><td>++</td><td>—</td><td>,</td><td>-&gt;*</td><td>-&gt;</td></tr><tr><td>()</td><td>[]</td><td>new</td><td>delete</td><td>new[]</td><td>delete[]</td></tr></tbody></table></div><p>大多数运算符都可以通过成员或非成员函数来重载。一般来说，非成员函数应是友元函数，这样它才能直接访问类的私有数据。在定义运算符时，必须选择其中的一种格式，而不能同时选择这两种格式。因为这两种格式都与同一个表达式匹配，同时定义这两种格式将被视为二义性错误，导致编译错误。</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元：C++提供的另一种访问类对象私有部分形式的访问权限。可将友元函数看作类的扩展接口的组成部分。</p><p>友元有3种：</p><ul><li>友元函数；</li><li>友元类；</li><li>友元成员函数。</li></ul><p><strong>友元函数</strong></p><p>通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。</p><p>用法示例：运算符通过非成员函数重载</p><p><strong>创建友元函数</strong></p><p>创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend。</p><ul><li>虽然友元函数函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；</li><li>虽然友元函数函数不是成员函数，但它与成员函数的访问权限相同。</li></ul><p>第二步是编写函数定义。因为它不是成员函数，所以不要使用Time::限定符。另外，不要在定义中使用关键字friend。</p><blockquote><p>提示：<br>如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以用友元函数来反转操作数的顺序。</p><p>警告：<br>只有在类声明中的原型中才能使用friend关键字。除非函数定义也是原型，否则不能在函数定义中使用该关键字。</p></blockquote><h2 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h2><p><strong>explicit关键字</strong>：关闭将构造函数用作自动类型转换函数的特性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explicit</span> [构造函数](...);</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>只接受一个参数的构造函数定义了从参数到类类型的转换。如果使用关键字explicit限定了这种构造函数，则它只能用于显示转换，否则可以用于隐式转换。</p></blockquote><p><strong>转换函数</strong>：从类类型转换到其它类型的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>转换函数必须是类方法；<br>转换函数不能指定返回类型；<br>转换函数不能有参数。</p><p>警告：<br>应谨慎地使用隐式转换函数。通常，最好选择仅在被显式地调用时才会执行的函数。</p></blockquote><p>总之，C++为类提供了下面的类型转换。</p><ul><li><p>只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。例如，将int值赋给Stonewt对象时，接受int参数的Stonewt类构造函数将自动被调用。然而，在构造函数声明中使用explicit可防止隐式转换，而只允许显式转换。</p></li><li><p>被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。转换函数是类成员，没有返回类型、没有参数、名为operator typeName()，其中，typeName是对象将被转换成的类型。将类对象赋给typeName变量或将其强制转换为typeName类型时，该转换函数将自动被调用。</p></li></ul><p><strong>转换函数和友元函数</strong></p><h1 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h1><p>静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。</p><p>静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员是const整数类型或枚举型，则可以在类声明中初始化。</p><h2 id="动态内存和类"><a href="#动态内存和类" class="headerlink" title="动态内存和类"></a>动态内存和类</h2><h3 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h3><p>C++自动提供了下面这些成员函数：</p><ul><li>默认构造函数，如果没有定义构造函数；</li><li>默认析构函数，如果没有定义；</li><li>复制构造函数，如果没有定义；</li><li>赋值运算符，如果没有定义；</li><li>地址运算符，如果没有定义。</li></ul><p>编译器将生成上述最后三个函数的定义——如果程序使用对象的方式要求这样做。</p><p>隐式地址运算符返回调用对象的地址（即this指针的值）。</p><p>默认析构函数不执行任何操作。</p><p>C++11提供了另外两个特殊成员函数：移动构造函数（move constructor）和移动赋值运算符（move assignment operator）。</p><h4 id="1．默认构造函数"><a href="#1．默认构造函数" class="headerlink" title="1．默认构造函数"></a>1．默认构造函数</h4><p>如果没有提供任何构造函数，C++将创建默认构造函数。例如，假如定义了一个Klunk类，但没有提供任何构造函数，则编译器将提供下述默认构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Klunk::<span class="built_in">Klunk</span>() &#123; &#125; <span class="comment">// implicit default constructor</span></span><br></pre></td></tr></table></figure><p>也就是说，编译器将提供一个不接受任何参数，也不执行任何操作的构造函数（默认的默认构造函数），这是因为创建对象时总是会调用构造函数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Klunk lunk; <span class="regexp">//</span> invokes default constructor</span><br></pre></td></tr></table></figure><p>默认构造函数使lunk类似于一个常规的自动变量，也就是说，它的值在初始化时是未知的。</p><p>如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象时不显式地对它进行初始化，则必须显式地定义默认构造函数。这种构造函数没有任何参数，但可以使用它来设置特定的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Klunk::<span class="built_in">Klunk</span>() <span class="comment">// explicit default constructor</span></span><br><span class="line">&#123;</span><br><span class="line">    klunk_ct = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。例如，Klunk类可以包含下述内联构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Klunk</span>(<span class="keyword">int</span> n = <span class="number">0</span>) &#123; klunk_ct = n; &#125;</span><br></pre></td></tr></table></figure><p>但只能有一个默认构造函数。也就是说，不能这样做：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Klunk() &#123; klunk_ct = <span class="number">0</span> &#125;           <span class="regexp">//</span> constructor <span class="comment">#1</span></span><br><span class="line">Klunk(int n = <span class="number">0</span>) &#123; klunk_ct = n; &#125; <span class="regexp">//</span> ambiguous constructor <span class="comment">#2</span></span><br></pre></td></tr></table></figure><p>这为何有二义性呢？请看下面两个声明：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Klunk kar(<span class="number">10</span>); <span class="regexp">//</span> clearly matches Klunt(int n)</span><br><span class="line">Klunk bus;     <span class="regexp">//</span> could match either constructor</span><br></pre></td></tr></table></figure><p>第二个声明既与构造函数#1（没有参数）匹配，也与构造函数#2（使用默认参数0）匹配。这将导致编译器发出一条错误消息。</p><h4 id="2．复制构造函数"><a href="#2．复制构造函数" class="headerlink" title="2．复制构造函数"></a>2．复制构造函数</h4><p>复制构造函数用于将一个对象复制到新创建的对象中。也就是说，它用于初始化过程中（包括按值传递参数），而不是常规的赋值过程中。类的复制构造函数原型通常如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Class_name</span>(<span class="keyword">const</span> Class_name &amp;);</span><br></pre></td></tr></table></figure><p>对于复制构造函数，需要知道两点：何时调用和有何功能。</p><h4 id="3．何时调用复制构造函数"><a href="#3．何时调用复制构造函数" class="headerlink" title="3．何时调用复制构造函数"></a>3．何时调用复制构造函数</h4><p>新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有的对象。例如，假设motto是一个StringBad对象，则下面4种声明都将调用复制构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBad <span class="title">ditto</span><span class="params">(motto)</span></span>;  <span class="comment">// calls StringBad(const StringBad &amp;)</span></span><br><span class="line">StringBad metoo = motto; <span class="comment">// calls StringBad(const StringBad &amp;)</span></span><br><span class="line">StringBad also = <span class="built_in">StringBad</span>(motto);</span><br><span class="line">                         <span class="comment">// calls StringBad(const StringBad &amp;)</span></span><br><span class="line">StringBad * pStringBad = <span class="keyword">new</span> <span class="built_in">StringBad</span>(motto);</span><br><span class="line">                         <span class="comment">// calls StringBad(const StringBad &amp;)</span></span><br></pre></td></tr></table></figure><p>其中中间的2种声明可能会使用复制构造函数直接创建metoo和also，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metoo和also，这取决于具体的实现。最后一种声明使用motto初始化一个匿名对象，并将新对象的地址赋给pStringBad指针。</p><p>每当程序生成了对象副本时，编译器都将使用复制构造函数。具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。记住，按值传递意味着创建原始变量的一个副本。编译器生成临时对象时，也将使用复制构造函数。例如，将3个Vector对象相加时，编译器可能生成临时的Vector对象来保存中间结果。何时生成临时对象随编译器而异，但无论是哪种编译器，当按值传递和返回对象时，都将调用复制构造函数。</p><p>由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。</p><h4 id="4．默认的复制构造函数的功能"><a href="#4．默认的复制构造函数的功能" class="headerlink" title="4．默认的复制构造函数的功能"></a>4．默认的复制构造函数的功能</h4><p>默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值。</p><p>如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态成员（如num_strings）不受影响，因为它们属于整个类，而不是各个对象。</p><p>如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。复制的另一种形式（成员复制或浅复制）只是复制指针值。浅复制仅浅浅地复制指针信息，而不会深入“挖掘”以复制指针引用的结构。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="　赋值运算符"></a>　赋值运算符</h3><p>ANSI C允许结构赋值，而C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的。这种运算符的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class_name &amp; Class_name::<span class="keyword">operator</span>=(<span class="keyword">const</span> Class_name &amp;);</span><br></pre></td></tr></table></figure><h4 id="1．赋值运算符的功能以及何时使用它"><a href="#1．赋值运算符的功能以及何时使用它" class="headerlink" title="1．赋值运算符的功能以及何时使用它"></a>1．赋值运算符的功能以及何时使用它</h4><p>将已有的对象赋给另一个对象时，将使用重载的赋值运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBad <span class="title">headline1</span><span class="params">(<span class="string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">StringBad knot;</span><br><span class="line">knot = headline1; <span class="comment">// assignment operator invoked</span></span><br></pre></td></tr></table></figure><p>这里，metoo是一个新创建的对象，被初始化为knot的值，因此使用复制构造函数。然而，正如前面指出的，实现时也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时对象的值复制到新对象中。这就是说，初始化总是会调用复制构造函数，而使用=运算符时也允许调用赋值运算符。</p><p>与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响。</p><h4 id="2．赋值的问题出在哪里"><a href="#2．赋值的问题出在哪里" class="headerlink" title="2．赋值的问题出在哪里"></a>2．赋值的问题出在哪里</h4><p>程序清单12.3将headline1赋给knot：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knot = headline1;</span><br></pre></td></tr></table></figure><p>为knot调用析构函数时，将显示下面的消息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Celery Stalks at Midnight&quot;</span> object deleted, <span class="number">2</span> left</span><br></pre></td></tr></table></figure><p>为Headline1调用析构函数时，显示如下消息（有些实现方式在此之前就异常终止了）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;-|&quot;</span> object deleted, <span class="number">-2</span> left</span><br></pre></td></tr></table></figure><p>出现的问题与隐式复制构造函数相同：数据受损。这也是成员复制的问题，即导致headline1.str和knot.str指向相同的地址。因此，当对knot调用析构函数时，将删除字符串“Celery Stalks at Midnight”；当对headline1调用析构函数时，将试图删除前面已经删除的字符串。正如前面指出的，试图删除已经删除的数据导致的结果是不确定的，因此可能改变内存中的内容，导致程序异常终止。要指出的是，如果操作结果是不确定的，则执行的操作将随编译器而异，包括显示独立声明（Declaration of Independence）或释放隐藏文件占用的硬盘空间。当然，编译器开发人员通常不会花时间添加这样的行为。</p><h4 id="3．解决赋值的问题"><a href="#3．解决赋值的问题" class="headerlink" title="3．解决赋值的问题"></a>3．解决赋值的问题</h4><p>对于由于默认赋值运算符不合适而导致的问题，解决办法是提供赋值运算符（进行深度复制）定义。其实现与复制构造函数相似，但也有一些差别。</p><ul><li>由于目标对象可能引用了以前分配的数据，所以函数应使用delete[ ]来释放这些数据。</li><li>函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容。</li><li>函数返回一个指向调用对象的引用。</li></ul>]]></content>
    
    
    <summary type="html">C++基础语法，《C++ Prime Plus》（第6版）读书笔记，待完善</summary>
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="高级语言" scheme="http://example.com/tags/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>行列式</title>
    <link href="http://example.com/2022/01/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <id>http://example.com/2022/01/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E8%A1%8C%E5%88%97%E5%BC%8F/</id>
    <published>2022-01-16T15:10:31.582Z</published>
    <updated>2022-01-17T13:20:06.879Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>行列式的几何意义</li><li>全排列</li><li>n阶行列式的定义</li><li>行列式的性质</li><li>行列式的性质</li><li>行列式按行按列展开</li></ul></blockquote><span id="more"></span><h1 id="行列式的几何意义"><a href="#行列式的几何意义" class="headerlink" title="行列式的几何意义"></a>行列式的几何意义</h1><p><strong>行列式</strong>可以看做是<strong>有向面积或体积</strong>的概念在一般的<strong>欧几里得空间</strong>中的推广。或者说，在 n 维欧几里得空间中，行列式描述的是一个<strong>线性变换</strong>对“体积”所造成的影响。</p><p><strong>线性变换</strong></p><blockquote><p>线性映射是从一个向量空间V到另一个向量空间W的映射且保持向量的可加性和成比例性，而线性变换是线性空间V到其自身的线性映射。</p><script type="math/tex; mode=display">可加性：L(\vec{v}+\vec{w})=L(\vec{v})+L(\vec{w})\\成比例性：L(c\vec{v})=cL(\vec{v})\\线性变换保持向量加法运算和数乘运算</script><p>微分算子是线性的，即求导具有可加性和成比例性</p></blockquote><p><strong>向量空间</strong></p><blockquote><p>向量空间满足向量加法和数乘规则</p><script type="math/tex; mode=display">\begin{array}&1.\vec{u}+(\vec{v}+\vec{w})=(\vec{u}+\vec{v})+\vec{w}\\2.\vec{v}+\vec{w}=\vec{w}+\vec{v}\\3.向量加法的单位元存在\\ 4.每个向量的加法逆元均存在\\5.a(b\vec{v})=(ab)\vec{v} \\6.向量乘法的单位元存在\\7.a(\vec{v}+\vec{w})=a\vec{v}+a\vec{w} \\8.(a+b)\vec{v}=a\vec{v}+b\vec{v} \\\end{array}</script><p>向量空间亦称线性空间；欧几里得空间是指一类特殊的向量空间，对通常3维空间的向量讨论长度、夹角等几何性质。                                                                                                                                     </p></blockquote><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p><strong>定义：</strong>把n个不同的元素排成一列，叫做n个元素的全排列。简称排列</p><p><strong>逆序数的定义：</strong>对于n个不同不同的元素，先规定各元素之间有一个标准次序，于是在这n个元素的任一排列中，当某一对元素的先后次序与标准次序不同时，就构成了一个逆序。一个排列中所有逆序的总数叫做这个排列的<strong>逆序数</strong>。</p><p>逆序数为奇数的排列叫做奇排列，逆序数为偶数的排列叫做偶排列。</p><blockquote><p>计算逆序数的方法：</p></blockquote><h1 id="n阶行列式的定义"><a href="#n阶行列式的定义" class="headerlink" title="n阶行列式的定义"></a>n阶行列式的定义</h1><p><strong>定义：</strong>设有n^2^个数，排成n行n列的数表</p><script type="math/tex; mode=display">\begin{bmatrix}a_{11} & a_{12} & ... & a_{1n} \\a_{21} & a_{22} & ... & a_{2n} \\...    &   ...  & ... & ...       \\a_{n1} & a_{n2} & ... & a_{nn} \\\end{bmatrix}</script><p>做出表中位于不同行不同列的n个数的乘积，并冠以符号(-1)^t^，得到形如<script type="math/tex">(-1)^{t}a_{1p_{1}}a_{2p_{2}}a_{3p_{3}}...a_{np_{n}}.(1)</script>其中p1,p2,p3…p n为自然数1,2,3,4…n的一个排列，t为这个排列的逆序数。将所有形如(1)式的所有项(n!项)的代数和<script type="math/tex">\sum(-1)^{t}a_{1p_{1}}a_{2p_{2}}a_{3p_{3}}...a_{np_{n}}</script>称为n阶行列式。</p><script type="math/tex; mode=display">D=\begin{bmatrix}a_{11} & a_{12} & ... & a_{1n} \\a_{21} & a_{22} & ... & a_{2n} \\...    &   ...  & ... & ...       \\a_{n1} & a_{n2} & ... & a_{nn} \\\end{bmatrix}</script><p>简称<script type="math/tex">det(a_{ij})</script>，其中<script type="math/tex">a_{ij}</script>为行列式D的(i , j)元。</p><blockquote><p>上三角行列式</p><p>对角行列式</p></blockquote><h1 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h1><p><strong>性质1：行列式与它的转置行列相等。</strong></p><p><strong>性质2：对换行列式的两行（列），行列式变号。</strong></p><blockquote><p>推论：如果行列式有两行（列）完全相同，则此行列式等于0。</p></blockquote><p><strong>性质3：行列式的某一行（列）中所有元素都乘同一个数K，等于用数K乘此行列式。</strong></p><blockquote><p>推论: 行列式中某一行（列）中的所有元素的公因子可以提到行列式记号的外面。</p></blockquote><p><strong>性质4：行列式中如果有两行（列）的元素成比例，则此行列式等于0。</strong></p><p><strong>性质5：若行列式的某一行（列）的元素都是两数之和，则D等于这两个行列式之和。</strong></p><p><strong>性质6：把行列式的某一行（列）的各个元素乘同一个数然后加到另一行（列）对应元素上，行列式不变。</strong>     </p><h1 id="行列式按行按列展开"><a href="#行列式按行按列展开" class="headerlink" title="行列式按行按列展开"></a>行列式按行按列展开</h1><p>在n阶行列式中，把(i,j)元a~ij~所在的第i行第j列划去后，留下的n-1阶行列式叫做(i,j)元a~ij~的余子式，记作<script type="math/tex">M_{ij}</script>；记<script type="math/tex">A_{ij}=(-1)^{i+j}M_{ij}</script>为代数余子式。</p><p><strong>引理 一个n阶行列式，如果其中第i行所有元素除(i,j)元a~ij~外都是0，那么这行列式等于aij与它的代数余子式的乘积。</strong></p><p><strong>定理2：行列式等于它的任一行（列）的各元素与对应的代数余子式成绩之和。</strong></p><blockquote><p>推论：行列式某一行（列）的元素与另一行（列）的对应元素的代数余子式乘积之和等于0。</p></blockquote>]]></content>
    
    
    <summary type="html">线性代数重要定理总结</summary>
    
    
    
    <category term="线性代数" scheme="http://example.com/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>矩阵</title>
    <link href="http://example.com/2022/01/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%9F%A9%E9%98%B5/"/>
    <id>http://example.com/2022/01/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%9F%A9%E9%98%B5/</id>
    <published>2022-01-16T15:10:31.580Z</published>
    <updated>2022-01-17T13:19:55.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>线性方程组和矩阵</li><li>矩阵的运算</li><li>逆矩阵</li><li>克拉默法则</li><li>矩阵分块法</li></ul></blockquote><span id="more"></span><h1 id="线性方程组和矩阵"><a href="#线性方程组和矩阵" class="headerlink" title="线性方程组和矩阵"></a>线性方程组和矩阵</h1><h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><h2 id="矩阵的定义"><a href="#矩阵的定义" class="headerlink" title="矩阵的定义"></a>矩阵的定义</h2><p><strong>定义1：有mxn个数aij(i=1,2,…,m;j=1,2,…,n)排成的m行n列的数表，称为m行n列的矩阵，简称mxn矩阵。</strong></p><blockquote><blockquote><p>实矩阵：元素为实数。</p><p>复矩阵：元素为复数。</p><p>n阶方阵\n阶矩阵：行数与列数都等于n。</p><p>对角阵（对角矩阵）：从左上角到右下角的直线（叫做对角线）以外的元素全为0的方阵。</p><p>两个矩阵行数、列数都相同时，就称它们是同型矩阵。</p></blockquote></blockquote><h1 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h1><h2 id="矩阵的加法"><a href="#矩阵的加法" class="headerlink" title="矩阵的加法"></a>矩阵的加法</h2><p><strong>定义2：设有两个mxn矩阵A=(<script type="math/tex">a_{ij}</script>)和B=(<script type="math/tex">b_{ij}</script>)，那么矩阵A与B的和记作A+B。 </strong></p><blockquote><p>对应位上的元素相加。</p><p>只有两个矩阵为同型矩阵时才能进行加法运算。</p><ul><li>A+B=B+A</li><li>(A+B)+C=A+(B+C)</li><li>A+(-A)=0</li></ul></blockquote><h2 id="矩阵的数乘运算"><a href="#矩阵的数乘运算" class="headerlink" title="矩阵的数乘运算"></a>矩阵的数乘运算</h2><p><strong>定义3：数λ与矩阵A的乘积记作λA或Aλ。</strong></p><blockquote><ul><li>(λξ)A=λ(ξA)</li><li>(λ+ξ)A=λA+ξA</li><li>λ(A+B)=λA+λB</li></ul></blockquote><h2 id="矩阵与矩阵的乘法"><a href="#矩阵与矩阵的乘法" class="headerlink" title="矩阵与矩阵的乘法"></a>矩阵与矩阵的乘法</h2><p><strong>定义4：设A=(<script type="math/tex">a_{ij}</script>)是一个mxs的矩阵，B=(<script type="math/tex">b_{ij}</script>)是一个sxn的矩阵,那么规定矩阵A与矩阵B的乘积是一个mxn矩阵C=(<script type="math/tex">c_{ij}</script>) 。</strong></p><blockquote><ul><li>(AB)C=A(BC)</li><li>λ(AB)=(λA)B</li><li>A(B+C)=AB+AC</li></ul></blockquote><p><strong>矩阵相乘的几何意义：两个线性变换的相继作用。</strong></p><h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><p><strong>定义5：把矩阵A的行列式换成同序数的列得到一个新矩阵，叫做A的转置矩阵，记作A^T^</strong></p><blockquote><ul><li>(A^T^)^T^=A</li><li>(A+B)^T^=A^T^+B^T^</li><li>(λA)^T^=λA^T^</li><li>(AB)^T^=B^T^A^T^</li></ul><p>如果$$A^T^=A，那么A称为对称矩阵，简称对称阵。</p></blockquote><h2 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h2><p><strong>定义6：由n阶矩阵A的元素所构成的行列式（各元素的位置不变），称为方阵A的行列式，记作detA或|A|。</strong></p><blockquote><ul><li>|A^T^|=|A|</li><li>|λA|=λ^n^|A|</li><li>|AB|=|A||B|</li><li>|AB|=|BA|</li></ul></blockquote><h3 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h3><p>定义：行列式|A|的各个元素的代数余子式A~ij~所构成的如下矩阵，称为矩阵A的伴随矩阵，简称伴随阵。</p><p><strong>AA^<em>^=A^</em>^A=|A|E</strong></p><h1 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h1><h2 id="逆矩阵的定义、性质和求法"><a href="#逆矩阵的定义、性质和求法" class="headerlink" title="逆矩阵的定义、性质和求法"></a>逆矩阵的定义、性质和求法</h2><p><strong>定义7：对于n阶矩阵A，如果有一个n阶矩阵B，使AB=BA=E，则说矩阵A是可逆的，并把B称为A的逆矩阵，简称逆阵。</strong>(B^-1^AB=A)</p><p>如果A是可逆的，那么A的逆矩阵是唯一的。</p><p>定理1：若矩阵A可逆，则|A|$\neq$0.</p><p>定理2：若|A|$\neq$0,则矩阵A可逆，且$A^{-1}=\frac{1}{|A|}A^{*}$ </p><p>当|A|为0时，称A为奇异矩阵，|A|不为0时，称A为非奇异矩阵。矩阵A可逆的充要条件为|A|$\neq$0，即可逆矩阵为非奇异矩阵。</p><blockquote><p>推论：若AB=E或（BA=E），则B=A^-1^.</p><p><strong>逆矩阵的运算规律：A,B可逆</strong></p><script type="math/tex; mode=display">\begin{array}&(A^{-1})^{-1}=A\\(λA)^{-1}=\frac{1}{λ}A^{-1}\\(AB)^{-1}=B^{-1}A^{-1}\end{array}</script></blockquote><h1 id="克拉默法则"><a href="#克拉默法则" class="headerlink" title="克拉默法则"></a>克拉默法则</h1><p><strong>如果线性方程组的系数矩阵的行列式不为0，那么方程组有唯一解</strong></p><blockquote><p>AX=B</p><p>系数矩阵A行列式为0时，线性变换后将向量空间压缩到一维，方程组有无穷多解或无解；</p><p>系数矩阵A行列式不为0，线性变换后向量空间维度不变，方程组有唯一解</p></blockquote><h1 id="矩阵分块法"><a href="#矩阵分块法" class="headerlink" title="矩阵分块法"></a>矩阵分块法</h1><hr><h1 id="矩阵的初等变换"><a href="#矩阵的初等变换" class="headerlink" title="矩阵的初等变换"></a>矩阵的初等变换</h1><p><strong>定义1 矩阵的初等行变换</strong></p><blockquote><ul><li>对换两行</li><li>以数K$\neq$0乘某一行中的所有元</li><li>把某一行所有元的k倍加到另一行对应的元上去</li></ul><p>矩阵之间的等价关系具有以下性质</p><ul><li>反身性    A~A</li><li>对称性   若A~B,则 B~A</li><li>传递性   若A~B, B~C, 则A~C</li></ul><p>行最简形矩阵：行阶梯形矩阵非零行的第一个非零元为1，阶梯口元素所在其他元素为0.</p><p>标准形矩阵：左上角是单位阵，其它元素皆为0。</p><p>矩阵初等行变换的应用：</p><script type="math/tex; mode=display">\begin{array}&1.(A|E)\Rightarrow(E,A^{-1})   \\ 2.若AX=B,求X:(A|B)\Rightarrow(E|A^{-1}B)         \\3.求A^{-1}B：(A|B)\Rightarrow(E|A^{-1}B) \\4.求R(A)\end{array}</script></blockquote><p><strong>定义2：（1）非零矩阵若满足（i）非零行在零行上面；（ii）非零行的首非零元所在列在上一行（如果存在的话）的首非零元所在列的右边，则称此矩阵为行阶梯形矩阵；（2）若A是行阶梯形矩阵，并且还满足：（i）非零行的首非零元为1；（ii）首非零元所在的列其他元均为0，则称A为行最简形矩阵。</strong></p><p><strong>定理1：设A与B为mxn矩阵，那么</strong></p><p><strong>（i）（r）A~B的充分必要条件是存在m阶可逆矩阵P，使PA=B;</strong></p><p><strong>（ii）（c）A~B的充分必要条件是存在n阶可逆矩阵Q，使AQ=B</strong></p><p><strong>（iii）A~B的充分必要条件是存在m阶可逆矩阵P及可逆矩阵Q，使PAQ=B</strong></p><p><strong>定义3：由单位矩阵E经过一次初等行变换得到的矩阵称为初等矩阵。</strong></p><p><strong>性质1：设A是一个mxn矩阵，对A实施一次初等行变换，相当于在A的左边乘相应的m阶初等矩阵；对A施行一次初等列变换，相当于在A的右边乘相应的n阶初等矩阵。</strong></p><p><strong>性质2：方阵A可逆的充分必要条件是存在有限个初等矩阵P1,P2,P3,…Pn,使A=P1P2P3…Pn</strong></p><blockquote><p>n阶可逆矩阵的行最简形矩阵是n阶方阵。</p><p>推论：方阵A可逆的充分必要条件是A~rE</p></blockquote><h1 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h1><p><strong>定义4：在mxn矩阵A中，任取k行k列</strong>($k \leq m, k\leq n$) <strong>,位于这些交叉处的k^2^个元素，不改变它们在A中所处的位置次序而得到的k阶行列式，称为矩阵A的k阶子式。</strong>  </p><p><strong>引理：设A~rB，则A与B中的非零子式的最高阶数相等。</strong></p><p><strong>定义5：设在矩阵A中有一个不等于0的r阶子式D，且所有r+1阶子式（如果存在的话）全等于0，那么D称为矩阵A的最高阶子式，数r称为矩阵A的秩，记作R（A）。并规定零矩阵的秩为0.</strong></p><blockquote><p>可逆矩阵又称满秩矩阵，不可逆矩阵（奇异矩阵）又称降秩矩阵。</p></blockquote><p><strong>定理2：若A~B，则R(A)=R(B). </strong></p><blockquote><p>推论：若可逆矩阵P、Q使PAQ=B，则R(A)=R(B).</p></blockquote><p>矩阵的秩的性质：</p><script type="math/tex; mode=display">\begin{array}&1.\leq R(A_{mxn})\leq min\{ m, n\} \\2.R(A^{T})=R(A)\\3.若A \backsim B，则R(A)=R(B).\\4.若P，Q可逆，则R(PAQ)=R(A)\\5.max\{R(A),R(B)\}\leq R(A,B) \leq R(A)+R(B)\\特别地，当B=b，    R(A)\leq R(A,b)\leq R(A)+1\\6.R(A+B)\leq R(A)+R(B)\\7.R(AB)\leq min\{R(A),R(B)\}\\8.若A_{mxn}B_{nxl}=0,则R(A)+R(B)\leq n\end{array}</script><blockquote><p>列满秩矩阵：矩阵的秩等于等于它的列数。</p><p>行满秩矩阵：矩阵的秩等于它的行数。</p></blockquote><p><strong>秩的几何意义：秩即线性变换后空间的维度，是列空间的维数</strong></p><h1 id="线性方程组的解"><a href="#线性方程组的解" class="headerlink" title="线性方程组的解"></a>线性方程组的解</h1><p><strong>定理3：n元线性方程组Ax=b</strong></p><ol><li>无解的充分必要条件是R(A)&lt;R(A,b)</li><li>有唯一解的充分必要条件是R(A)=R(A,b)=n(维度不变)</li><li>有无限多解的充分必要条件是R(A)=R(A,b)&lt;n</li></ol><blockquote><script type="math/tex; mode=display">\begin{array}&1.|A|\neq 0 \Rightarrow R(A)=n\Rightarrow R(A,b)=n\Rightarrow Ax=b有解  \\2.|A|=0\Rightarrow R(A)<n\Rightarrow Ax=b无解or无穷多解\end{array}</script></blockquote><p><strong>定理4：n元齐次方程组Ax=0有非零解的充分必要条件是R(A)&lt;n;</strong></p><p><strong>定理5：线性方程组Ax=b有解的充分必要条件是R(A)=R(A,b) </strong></p><p><strong>定理6：矩阵方程AX=B有解的充分必要条件是R(A)=R(A,B) </strong></p><p>定理7：设AB=C，则$R(C)\leq min\{R(A),R(B) \}$ </p>]]></content>
    
    
    <summary type="html">线性代数重要定理总结</summary>
    
    
    
    <category term="线性代数" scheme="http://example.com/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
</feed>
